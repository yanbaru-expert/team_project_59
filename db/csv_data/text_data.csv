genre,title,content
basic,Macのショートカットキー,"パソコンになれてないなら、まずはショートカットキーから使えるようにしていきましょう。ここにあげてあるショートカットキーを使えないと、プログラミングの学習効率は全く上がらないです。

プログラマーなるなら必須中の必須なので、ぜひ使いこなせるようにしてください。絶対にこれだけは覚えて！というショートカットキーは以下の通り。

上書き保存

```
command + s
```

コピー

```
command + c
```

カット

```
command + x
```

ペースト

```
command + v
```

更新

```
command + r
```

新しいウインドウを開く（ブラウザ、テキストエディタなど）

```
command + t
```

新規で開く（ブラウザ、テキストエディタなど）

```
command + n
```

アプリの切り替え

```
shift + tab
```

# まとめ
パソコンの操作スピードを上げるためにも、ショートカットキーを活用することはとても重要になってきます。特に、コピー&ペーストや上書き保存は、ショートカットキーを使用するのとそうでないのでは大きな差が出てくるので、ぜひ使えるようにしておきましょう。
"
basic,Linuxコマンド,"Linuxコマンドは、Ruby on Railsアプリを開発するときにもよく使うコマンドです。Macでプログラミングを学ぶ際に、このLinuxコマンドの知識が必須となりますので、一つ一つ確認していきましょう。

また、Linuxコマンドにはたくさんの種類がありますが、こちらではよく使用するコマンドを抽出して載せるようにします。上に書いてあるものから順に覚えて行くと無駄なく学習することができます。

## cd
ディレクトリ間を移動するときのコマンドは以下のようになります。 `directory_name` には、自分が移動したいディレクトリの名前を入れましょう。

```
cd directory_name
```

ためしに、 `cd` コマンドを利用して `desktop` へ移動してみましょう。

```
cd desktop
```

コマンドを実行した後のターミナルの表示に `desktop` という表示が含まれていれば移動は成功です。ターミナルでは、このように `cd` コマンドを利用してパソコン内を移動します。非常によく利用するコマンドなので、是非使えるようにしておきましょう。

```
MacBook-Pro-2:desktop your_name$
```


## ls
現在操作を行なっているディレクトリにあるファイルや、他のディレクトリを一覧表示するためには`ls`コマンドを実行します。 `cd` コマンドでディレクトリ間の移動を行い、 `ls` コマンドで操作したいディレクトリやファイルが存在するかどうかを調べるというのがよくある使い方です。

```
ls
```

## pwd
ターミナル上で操作対象となっているディレクトリの場所を表示するコマンドです。これを実行すると、ディレクトリのパスが表示されます。

```
pwd
```

実行結果

```
/Users/yoshito/desktop
```

## touch
新しいファイルを作成するときには`touch`コマンドを使用します。`directory_name`には自分が作成したいファイル名を拡張子を含めて指定します。

```
touch file_name
```

例

```
touch sample.rb
```

## mkdir
新しいディレクトリを作成するときは`mkdir`コマンドを使用します。`directory_name`には自分が作成したいディレクトリ名を指定します。

```
mkdir directory_name
```

例

```
mkdir sample
```

# まとめ
Linuxコマンドは、Macの操作をする上ではとても重要なコマンドとなります。プログラミングをやるときにも、これらのコマンドはよく使用するのでぜひ使えるようにしてみてください。"
basic,Slackを使用したいろんなマークダウン記法,"Slackを使いこなすと、プログラミング学習の効率もぐんと上がる（特に質問の仕方が上手くなる）ので、ぜひマークダウン記法を利用してみてください！


|No.|記入方法|用途|
|---|---|---|
|1|@hoge|hogeさん、あるいは hoge グループあてのコメントになる|
|2|#hoge|	チャンネル　hoge へのリンクになる|
|3| \`サンプルコード \`|ボーダーで囲まれ、文字色赤、背景灰色になる|
|4| \`\`\` サンプルコード \`\`\` |ボーダーで囲まれ、 \`\`\` で発言を開始すると再び \`\`\` が来るまでは改行しても送信しない|
|5|>引用文|引用表現にする|
|6|>>>引用文|改行含めた段落全体を引用表現にする|
|7|\_slack_|文字をイタリックにする|
|8|\*slack*|文字をボールドにする|
|9|\~slack~|文字をストライク（取り消し線）にする|


No.3, 4 の記法を使用した時の表示は以下のようになります。

`No.3の書き方：1行のコードを書く場合`

```
No.4の書き方
複数行のコードを書く場合
```

# まとめ
Slackにおいてマークダウンを使用するとコミュニケーション効率が圧倒的に上がるので、ぜひ活用して見てください。"
git,Gitの基本,"Gitとは、プログラムのソースコードなどの変更履歴を記録・追跡するためのバージョン管理システムのことです。バージョン管理とは、その名の通り、複数存在するソースコードのバージョンを管理することを指します。

このGitを使用することによって、変更履歴をさかのぼってソースコードを元の状態に戻す事ができ、複数人での共同開発も可能になります。

![Gitでできること](/git_basic/git_basic.jpg)

チームでの共同開発をする上で、もはやGitは欠かせない存在となっています。

プログラマーというとコードを書いているイメージがあるかと思いますが、それ以前にGitなどのバージョン管理ツールが無ければ仕事になりません。ぜひ、ここで基礎を押さえておきましょう。


## Gitにおける開発の流れ
まずは基本的な用語から押さえておきましょう。

Gitがバージョン管理下におく場所を「リポジトリ」と言います。リポジトリには「ローカルリポジトリ」と「リモートリポジトリ」があります。

ローカルリポジトリは自分のパソコン内にあるリポジトリ、リモートリポジトリはネット上にあるリポジトリと覚えておきましょう。

リモートリポジトリに関しては、後ほど詳しくご説明いたします。

ユーザが変更の履歴を保存することをコミット（commit）と言います。

これはGitの持つ機能の中でも特によく使用するので、ぜひ覚えておいてください。

コミットは実行した順番で記録されるので、時系列に沿って変更履歴を追う事ができます。

そのため、過去にどういう変更を行ったのかを簡単に確認する事ができるのです。

また、コミットをする際にはコミットメッセージという形でメモを残す事ができます。

例えば、「デザインの変更をしました」とか「データベースへの登録処理を追加しました」といったメモを残す事ができるというわけです。それによって、より変更履歴の理解が容易になります。

複数人での開発を行う際は、この「コミット」と「コミットメッセージ」を利用し、誰がみても理解できるような変更履歴を作成し、任意の履歴に遡ることができるよう心がけましょう。

## gitの構成
詳細な説明に入る前に、まずはGitがファイルの状態を保存する場所についてご説明します。

実は、Gitにはファイルを保存するための場所がいくつかあります。その構成は以下の通りです。

1. ワーキングツリー（今作業しているファイルのある場所）
2. インデックス（コミットするためのファイルを登録する場所）
3. ローカルリポジトリ（リモートリポジトリに変更内容を送信するための場所）
4. リモートリポジトリ（複数人でファイルを共有するための場所）

## 同時並行で複数の開発を可能にする機能
Gitには、複数の開発を同時並行することができる機能があります。

例えば、Aさんはデータの登録を行う処理を実装し、Bさんはデータの表示形式を綺麗にするという実装をするとします。

そのとき、2人で同じファイルを編集すると、とても効率が悪くなります。

その問題を解決するための機能が「ブランチ」です。ブランチとは、文字通り開発を枝分かれさせる機能のことで、これを使用することによってAさんとBさんの開発を別々のものとして扱うことができます。

例）
Aさん　→ ブランチA
Bさん　→ ブランチB

## ローカルリポジトリとリモートリポジトリ
前述でGitのバージョン管理下にある場所をリポジトリというというお話をしました。

その中でも、ネットを介してどこからでも利用できるようにしたリポジトリのことをリモートリポジトリと言います。

それとは逆に、自分のパソコン内にあるリポジトリのことろローカルリポジトリと言います。

複数人での開発を行うときは、リモートリポジトリを複数のプログラマーで共有し、そのリモートリポジトリのクローンをそれぞれのプログラマーがローカルリポジトリにコピーして開発を行うというスタイルになります。

これによって、１つのプロジェクトを複数人で開発することが可能になるわけです。

## バージョン管理の流れ
Gitでのバージョン管理は基本的に以下のような流れになります。

- ローカルリポジトリの作成（git init）
- 変更ファイルをインデックスにあげる（git add）
- 変更履歴を保存する（git commit）

## 今回使用するサンプル
今回は、Hello World!!と表示する単純なHTMLファイルを利用して、Gitの使い方を学んでいきましょう。

`git_sample`というディレクトリを作成し、テキストエディタで`git_sample.html`というファイルを作成しましょう。

まずは、サンプルファイルを置くための`git_sample`ディレクトリをターミナルから作成しましょう。

```
mkdir git_sample
```

ディレクトリが作成できたら、cdコマンドで`git_sample`ディレクトリに移動しましょう。

```
cd git_sample
```

ディレクトリに移動できたら、`git_sample.html`を作成します。

ファイルに関しては、テキストエディタから作成してもいいのですが、ターミナルから作成することも可能です。

その際は、`touch`コマンドを使用します。`git_sample.html`という名前のファイルを作成する場合は、以下のコマンドを実行しましょう。

```
touch git_sample.html
```

これで、Gitの練習をする準備が整いました。それではさっそく、Gitコマンドについて学んでいきましょう。

## Gitをインストールする
Gitをパソコンで使用できるようにするためには、まずはインストールを行わなければいけません。

そのGitをインストールするためには、Homebrewというパッケージ管理ツールを使用すると楽なので、まずはHomebrewからインストールしましょう。

以下のコマンドをターミナルにコピー&ペーストして実行してください。それだけで、Homebrewがインストールできます。

```
/usr/bin/ruby -e ""$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)""
```

Homebrewのインストールが終わったら、以下のコマンドをターミナルに入力し、Homebrewを使用してGitをインストールします。

```
brew install git
```

インストールが完了したら、いよいよGitを利用したバージョン管理の方法について学んでいきます。なんども基礎を繰り返し、バージョン管理のスキルをしっかりと身につけていきましょう！

## ローカルリポジトリを作る
cdコマンドを利用してローカルリポジトリを作成したいディレクトリに移動できたら、`git init`というコマンドを実行します。

このコマンドで、ディレクトリ内に中身が空のローカルリポジトリを作成します。また、すでにリポジトリが存在している場合には、再度`git init`を実行する必要はありません。

```
git init
```

`ls`コマンドを入力し、gitのリポジトリができていることを確認しましょう。

以下のように.Gitというディレクトリが作成されて入れば成功です。

```
ls -la
```


## サンプルを編集する
それでは、先ほど作成した`git_sample.html`の内容を変更しましょう。以下のコードを追加してください。

```
<h1>Hello World!!</h1>
```

以上のように変更できたら、次はその変更履歴を`Git`を使用して保存します。

## ファイルをインデックスに登録する
`git init`実行後、現在作成したファイルの変更履歴を保存するために`git add .`を実行します。

このコマンドは、現在開発しているプロジェクトの中で変更があったファイルを見つけてインデックスに上げ、変更履歴を保存するための準備をしてくれます。

要するに、「変更した全てのファイル」を「Gitによってバージョン管理するための対象」に入れるということです。それでは、`git add .`を実行しましょう。

```
git add .
```

ちなみに、`git add .`は変更したファイルをまとめてインデックスにあげるためのコマンドになります。

そのほかにも、特定のファイルのみをインデックスに上げるコマンドもあります。

その場合は、`git add ファイル名`コマンドを実行します。

例） sample.rbというファイルのみをインデックスに上げる場合のコマンド

```
git add sample.rb
```

## 変更履歴を保存する
変更履歴を保存するには、`commit`というコマンドを実行します。

このコマンドを実行すると、ローカルリポジトリの変更内容を保存します。

また、`commit`を実行する際には`git add`において変更済みのファイルがインデックスにあることが必須となります。

もし変更済みのファイルがインデックスにない場合は、`commit`するものが無いというメッセージが表示されます。

```
nothing to commit, working tree clean
```

`commit`を実行する際は、以下のコマンドを入力します。`-m`や`--message`オプションをつけることによって、コミットに対するコメントを残すことができます。

これにより、各コミットにおいてどのような変更が行われたのかを把握しやすくすることができます。

```
git commit -m ""init commit""
```

## コミットまでの流れのおさらい
それでは、ファイルを変更してからコミットするまでの流れを改めておさらいしましょう。

先ほど作成した`git_sample.html`の内容を以下のように変更しましょう。

```
<h1>Good morning!!</h1>
```

変更したファイルをインデックスに登録します。

```
git add .
```

インデックスに登録したファイルをコミットします。

```
git commit -m ""change message""
```

これで、ファイルを変更してからコミットまでの一連の流れが終了です。

 `git add` を実行してから `git commit` という流れをなんども繰り返して体に覚えさせるようにしましょう。

## 変更履歴のメッセージを修正する
コミットメッセージを修正したい時には、以下のコマンドを実行します。

```
git rebase -i HEAD^
```

それでは、過去のコミットメッセージを変更してみましょう。

まずは、過去のコミットメッセージを確認してください。

```
git log
```

そうすると、過去のコミット一覧が表示され、それに対応するコミットメッセージも確認できます。


```
change message
```

今回は、`change message`というメッセージを`change hello to good morning`に変更しましょう。

それではさっそく、以下のコマンドを実行してください。

```
git rebase -i HEAD^
```

そうすると、以下のような画面が表示されます。

```
pick 65e1b59 change message

# Rebase d9a2c59..65e1b59 onto d9a2c59 (1 command)
#
# Commands:
# p, pick = use commit
# r, reword = use commit, but edit the commit message
# e, edit = use commit, but stop for amending
# s, squash = use commit, but meld into previous commit
# f, fixup = like ""squash"", but discard this commit's log message
# x, exec = run command (the rest of the line) using shell
# d, drop = remove commit
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
# Note that empty commits are commented out
~
~
~
""~/git_sample/.git/rebase-merge/git-rebase-todo"" 20L, 680C
```

その表示の中で、一番上に書かれている`pick`の部分を`r`に変更するとコミットメッセージを編集することができます。

その際、`i`を押して表示を`INSERT`モードに切り替えてください。そうすると、以下のように画面の一覧下に`INSERT`という文字が表示されます

```
pick 65e1b59 change message

# Rebase d9a2c59..65e1b59 onto d9a2c59 (1 command)
#
# Commands:
# p, pick = use commit
# r, reword = use commit, but edit the commit message
# e, edit = use commit, but stop for amending
# s, squash = use commit, but meld into previous commit
# f, fixup = like ""squash"", but discard this commit's log message
# x, exec = run command (the rest of the line) using shell
# d, drop = remove commit
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
# Note that empty commits are commented out
~
~
~
-- INSERT --
```

`INSERT`が表示されたら、`pick`の部分を`r`に書き換えましょう。

```
r 65e1b59 change message

# Rebase d9a2c59..65e1b59 onto d9a2c59 (1 command)
#
# Commands:
# p, pick = use commit
# r, reword = use commit, but edit the commit message
# e, edit = use commit, but stop for amending
# s, squash = use commit, but meld into previous commit
# f, fixup = like ""squash"", but discard this commit's log message
# x, exec = run command (the rest of the line) using shell
# d, drop = remove commit
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
# Note that empty commits are commented out
~
~
~
""~/git_sample/.git/rebase-merge/git-rebase-todo"" 20L, 680C
```

書き換えられたら、キーボードの左上にある`esc`を押し、`:wq`で上書き保存します。そうすると、次にコミットメッセージが表示されます。

```
chnage message

# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
#
# Date:      Mon Sep 10 12:58:07 2018 +0900
#
# interactive rebase in progress; onto d9a2c59
# Last command done (1 command done):
#    r 65e1b59 change hello to good morning
# No commands remaining.
# You are currently editing a commit while rebasing branch 'master' on 'd9a2c59'.
#
# Changes to be committed:
#       renamed:    .git_sample.rb.swp -> .git_sample.rb.swo
#       modified:   git_sample.rb
#
~
~
~
~
~
~
""~/git_sample/.git/COMMIT_EDITMSG"" 17L, 563C
```

コミットメッセージが確認できたら、`i`をクリックして`INSERT`モードに切り替え、コミットメッセージを変更します。

```
change hello to good morning

# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
#
# Date:      Mon Sep 10 12:58:07 2018 +0900
#
# interactive rebase in progress; onto d9a2c59
# Last command done (1 command done):
#    r 65e1b59 change hello to good morning
# No commands remaining.
# You are currently editing a commit while rebasing branch 'master' on 'd9a2c59'.
#
# Changes to be committed:
#       renamed:    .git_sample.rb.swp -> .git_sample.rb.swo
#       modified:   git_sample.rb
#
~
~
~
~
~
~
""~/git_sample/.git/COMMIT_EDITMSG"" 17L, 563C
```

メッセージが変更できたら、`esc`を押し、`:wq`で変更内容を保存しましょう。そのあと、以下のコマンドを入力してコミットメッセージが変更されていることを確認してください。

以上で、コミットメッセージの変更は終了です。

## ブランチを作成する
ブランチとは、複数の開発を同時並行して行うために必要な仕組みです。

変更履歴の管理を分岐させることによって、各プログラマーで別々の機能を実装する事ができます。「ブランチ」という名前の通り、開発を枝分かれさせるという事ですね。そのブランチを作成するには、以下のコマンドを実行します。

ブランチは、他のブランチに合体（マージ）させる事で、一つにまとめる事ができます。

`master`と呼ばれるブランチが存在し、開発用に分岐させた他のブランチは、最終的にこの`master`にマージさせるというのが、一般的な開発の流れです。

```
git branch ブランチ名
```

`git branch`の後ろに任意のブランチ名をつける事によって、その名前で新しいブランチを作り出す事ができます。

例えば、`sample`という名前のブランチを作成したいときは、以下のようにコマンドを入力します。

```
git branch sample
```

現在存在するブランチを確認したい場合は、`git branch`を実行するだけで大丈夫です。

```
git branch
```

新しくブランチを作成し切り替えるコマンドは以下の通りです。

```
git checkout -b sample
```

## ブランチを切り替える
ブランチが作成できたら、つぎにその切り替え方を学んでいきましょう。現在、`git branch`を実行すると以下のような表示がされるかと思います。

```
* sample
  master
```

その状態で、`git_sample.html`の内容を以下のように編集してみましょう。

```
<h1>こんにちは！！</h1>
```

上記のようにコードを変更できたら、次はその変更履歴を保存します。

これまでの一連の流れを、ここで改めて確認しましょう。

変更したファイルをインデックスにあげる

```
git add .
```

変更履歴を保存する

```
git commit -m ""changed english to japanese""
```

変更履歴が保存できたら、

## ブランチをマージする（ローカルで完結）
開発が完了したブランチを他のブランチに合体することをマージと言います。

今回は、`sample`ブランチから`master`ブランチへマージする例を見て見ましょう。

まず、今存在しているブランチを確かめます。

```
git branch
```

出力結果

```
* sample
  master
```

`sample`ブランチから、`master`ブランチへと切り替えます。その際、使用するコマンドは`checkout`です。

```
git checkout master
```

次に、`merge` コマンドを利用して、 `sample` ブランチを `master` にマージさせます。これでマージは完了です。

```
git merge sample
```

ブランチを消すときは以下のコマンドを実行します。マージが終わったらいらないブランチは削除するようにしましょう。

```
git branch -d sample
```

# まとめ
以上でGitの基本操作は終わりです。

基本といっても、初心者の方にはとても難易度の高い作業であり、わからない部分があって当然です。

不明点がある場合はすぐに神里に聞いてください。また、この項目をなんども繰り返してちょっとずつ理解を深めていってください。

プログラミングは一回やれば身につくというものではありません。しかし、何度もやると以前は1時間かかったものが一瞬で終わるようになることもよくあります。

なので、ぜひご自身の成長を楽しみながら続けていっていただけると幸いです。

お疲れ様でした！"
git,Gitで使用するテキストエディタ、Vimの使い方,"Vimとは、かなり歴史のあるテキストエディタです。初心者からすると難しそうな印象ですが、コアなユーザーの多いエディタです。

# Vimの使い方
Vimはモードを使い分けることによって色々な操作ができるようになっています。

|操作|入力キー|
|---|---|
|カーソルを↑に移動|k|
|カーソルを↓に移動|j|
|カーソルを←に移動|h|
|カーソルを→に移動|l|
|一文字削除|x|
|インサートモードへ|i|
|次行を新規行として挿入してインサートモードへ|o|
|現在行に新しい行を追加してインサートモードへ|O|
|インサートモードからノーマルモードへ	|esc|

以上のような操作を使い分けて、行いたい処理を実行します。

例えば、コードの編集を行いたいときは`i`でインサートモードに切り替え、編集が終わったら`esc`でノーマルモードに戻すわけです。

# 保存や終了に関する操作
Vimでは、ファイルを編集した後の操作にもコマンドを使用します。

|操作|入力キー|
|---|---|
|上書き保存|:w|
|名前をつけて保存|:w ファイル名|
|編集終了|:q|
|保存して終了|:wq または :x|
|ファイルを開く|:e ファイル名|

ファイルを編集した場合は、一度`esc`を押してインサートモードからノーマルモードへ切り替えて行いましょう。

その後、`:w`を入力すると上書き保存ができ、`:q`通すとVimを終了させることができます。

ちなみに、`:wq`を入力すると上書き保存と終了を一度に行うことができます。

# まとめ
Vimは使い方にちょっと癖がありますが、慣れれば普段のテキストエディタと同じように使えます。人によっては、Vimの方が圧倒的にいいという人もいるくらいです。

AWSやGitでも、Vimを使用してファイルを編集することがあるので、基本的な使い方はマスターしておきましょう。現場でも、きっと使う場面が出てくるはずですよ。
"
git,Gitコマンド一覧,"Gitに関して、よく使うコマンドを一覧にしています。復習にお役立てください。

Gitでのバージョン管理を開始する

```
git init
```

変更したファイルをインデックスにあげる

```
git add .
```

特定のファイルのインデックスへの追加を取り消す

```
git reset HEAD config/database.yml
```

変更履歴を保存

```
git commit -m ""message""
```

コミットの履歴を確認

```
git log
```

変更内容を一時的に退避（コミットする前の変更内容）

```
git stash
```

退避した変更を復元する

```
git stash pop
```

変更したファイルをリモートリポジトリに反映

```
git push origin remote_url
```

リモートリポジトリの状態を無視して強制プッシュ

```
git push -f origin remote_url
```

ブランチの確認

```
git branch
```

ブランチの切り替え

```
git checkout branch_name
```

ブランチを新規作成して切り替えまでを一気にやる

```
git checkout -b new_branch_name
```

ブランチ名の変更

```
git branch -m new_branch_name
```

過去のコミットの状態にファイルを戻す（1つ前に戻す）

```
git checkout HEAD^
```

過去のコミットの状態にファイルを戻す（3つ前に戻す）

```
git checkout HEAD^^^
```

リポジトリをクローンする

```
git clone github_url
```

前回のコミットとの変更点の差分を確認する

```
git diff HEAD^
```

2つ前のコミットとの変更点の差分を確認する

```
git diff HEAD^^
```

リモートリポジトリの変更内容をローカルリポジトリに反映させる（リモートリポジトリにあるブランチがローカルリポジトリに反映される）

```
git fetch
```

リモートリポジトリのブランチを確認する

```
git branch -a
```

HEADにマージしたローカルリポジトリのブランチを消す

```
git branch --delete branch_name
```

マージの有無にかかわらずローカルリポジトリのブランチを消す

```
git branch -D branch_name
```

過去のコミット3つ分をまとめる（コミットメッセージの変更もできる）

```
git rebase -i HEAD^^^
```

ローカルの変更内容を取り消す（新規追加したファイルは削除されない）

```
git checkout .
```"
ruby,入出力を行うためのメソッド一覧,"Rubyには、ターミナルに様々なデータを表示するためのメソッドがいくつか用意されています。

- puts
- p
- print

特に、 `puts` と `p` に関しては、ログの表示、テスト、デバッグなど、様々な場面で利用されます。

基本的、かつ、非常に汎用性の高いメソッドなので、ぜひ使えるようにしてみてください。

# puts
`puts` は、データを出力する際に、最後に改行が入ります。

ターミナルに値を出力する際には、この `puts` が非常によく使われるので、ここで使い方を理解しておきましょう。

## 文字の表示
putsの基本的な使い方は以下の通りです。

```ruby
puts ""Hello World!!""
```

以上のように書くと、ターミナルに `Hello World!!` という文字列が表示されます。ここで注意しなければいけないのは、文字列を表示するときは `""""（ダブルクウォーテーション）` で囲むということです。これがないと文字列として認識してもらえずエラーになるので注意してください。

それでは実際に、 `puts` を使って `Hello World!!` を表示してみましょう。そのためにまずは、Rubyのファイルを作成します。テキストエディタを立ち上げ、 `command + s` で保存しましょう。

上書き保存（最初の一回は名前をつけて保存）

```
command + s
```

ファイル名は `hello.rb` にしてください。その時に使用する `.rb` は `拡張子` と呼ばれるものです。

これにより、どういう種類のファイルなのかをコンピュータに認識させることができます。

拡張子には、 `.rb` の他にも `Word` ファイルを表す `.docx` や `PDF` ファイルを表す `.pdf` などいろんな種類があります。

今回は、Rubyのファイルなので拡張子に `.rb` とつけて保存します。保存先はデスクトップにしてください。

```
hello.rb
```

ファイルが保存できたら、 `hello.rb` に以下のコードを書きましょう。

`puts` のコードを入力する際には、 `""Hello World!!""` との間に半角スペースを入れてください。

```ruby
puts ""Hello World!!""
```

そして、コードを書いたら必ず `command + s` で上書き保存する癖をつけてください。本当によく使う機能なので、このショートカットキーは覚えておくとかなり楽です。

ではさっそく、`hello.rb`の中に記述したコードをターミナルから実行してみましょう。まずは、`cd`コマンドを使用して、ターミナルでデスクトップに移動します。

```
cd desktop
```

このように、Rubyのコードを実行する場合は、コードを書いたファイルがある場所まで移動します。

もし、今回作成した `hello.rb` を `ruby_sample` というフォルダ（ディレクトリ）に保存した場合は `cd ruby_sample` というコマンドをターミナルに入力して移動します。

ちなみに、 `cd` は `change directory` という意味になります。

`cd` コマンドで移動ができたら、以下のコマンドを入力してコードを実行してください。

```
ruby hello.rb
```

実行結果

```
Hello World!!
```

今回出力した `Hello World` は、「文字列」と呼ばれるものです。

プログラミングでは、文字のことを文字列、数字のことを整数や少数などという風に区別します。

例えば、 `""1""` は文字列 `1` は整数となり、全く別のデータとして扱われることに注意してください。

`1 + 2` は答えが `3` として計算できますが、 `""1 + 2""` はただの文字列なので計算できません。

また、文字列の場合は `'（シングルクウォーテーション）` または `""（ダブルクウォーテーション）` で値を囲む必要があります。

基本的にはダブルクウォーテーションが多いのですが、2種類の表現方法があることを頭に入れておいてください。

それでは、以下のコードを `hello.rb` に記述してください。

```ruby
puts 'Single Hello World'
puts ""Double Hello World""
```

ターミナルで以下のコマンドを入力し、プログラムを実行しましょう。

```
ruby hello.rb
```

そうすると以下のような表示になります。シングルクウォーテーションもダブルクウォーテーションも、どちらも表示には違いがないことを確認しましょう。

```
Single Hello World
Double Hello World
```

また、コード内にはメモが書けるということもここで理解しておきましょう。

以下のように `#` を使用してメモを追加してみてください。

```ruby
# 文字を出力するコード
puts 'Single Hello World'
puts ""Double Hello World""
```

ターミナルで以下のコマンドを入力し、プログラムを実行しましょう。

```
ruby hello.rb
```

そうすると以下のような表示になります。

```
Single Hello World
Double Hello World
```

このように、 `#` の後にコメントを書いても実行結果には影響を与え無いことを理解しておきましょう。

なので、自分自身が気づいたことや説明などは、 `#` の後にメモとして記述してください。そうすると、復習するときにとても役に立ちます。

```ruby
# 文字を出力するコード
# シングルクウォーテーションでの記述
puts 'Single Hello World'
# ダブルクウォーテーションでの記述
puts ""Double Hello World""
```

## 数字の表示
`puts` を使って数字を表示するときは以下のように書きます。

```ruby
puts 3
```

文字列のように `""""` を書く必要はありません。

それでは、 `number.rb` をデスクトップに作成し、以下のコードを書いて実行してみましょう。

コードを実行する際は、 `cd` コマンドを使用してファイルのある場所まで移動することを忘れず行ってください。

今回も、 `number.rb` をデスクトップに作成したので、ターミナルでも以下のコマンドを実行してデスクトップに移動します。（すでにデスクトップに移動できている場合は実行しなくて大丈夫です）

```
cd desktop
```

 `number.rb` に、以下のコードを書いてください。

```ruby
puts 1
```

実行結果

```
1
```

以上のように、整数を表示するときは `""""` で囲む必要がないことを理解しておきましょう。

また、計算式を書くと自動で値を計算し、その結果を出力してくれます。

```ruby
# 数字の場合
puts 1 + 3
# 文字列の場合
puts ""1 + 3""
```

実行結果

```
4
1 + 3
```

このように、Rubyでは計算結果を `puts` で出力することもできます。また、`""""` で囲んだ場合は数字ではなく文字列として認識されるので、計算はできないことに注意しましょう。

今回は足し算を例に出しましたが、Rubyに用意されている計算方法はそれだけではなく、引き算、掛け算、割り算などの計算も行えます。良い機会なので、Rubyでの四則演算についてもついでに理解しておきましょう。

また、この計算方法についてはだいたいどの言語でも同じなので、頭に入れておくと他の言語にも幅広く応用できます。

## 四則演算
Rubyでの四則演算には以下の種類があり、計算する時に使用される記号は`演算子`と呼ばれます。

|演算子|内容|例|
|---|---|---|
|+|足し算（加算）|2 + 2|
|-|引き算（減算）|3 - 3|
|*|かけ算（乗算）|4 * 4|
|/|割り算（除算）|5 / 5|

ではさっそく`puts`を利用し、四則演算の計算結果を表示してみましょう。

```ruby
puts 2 + 2
puts 3 - 3
puts 4 * 4
puts 5 / 5
```

実行結果

```
4
0
16
1
```

もちろん、演算子は複数続けて記述することもできます。

```ruby
puts 2 + 2 + 2
```

ただし、文字と数字を続けて表示する場合、以下のように書くとエラーになります。

```ruby
puts ""2 + 2 = "" + 4
```

実行結果

```
TypeError: no implicit conversion of Fixnum into String
```

その理由は、「文字」と「数字」という種類の異なるデータで足し算しようとしたためです。

これだと、正常な処理ができません。

もし、上記のやり方でエラーを回避したい場合は、`to_s`メソッドを使用して数字を文字に変換してあげます。

```ruby
puts ""2 + 2 = "" + 4.to_s
```

実行結果

```
2 + 2 = 4
```

このように、「文字」と「数字」という種類の異なるデータを表示する場合は特別な変換をする必要があることを理解しておいてください。

そして、変換が必要かどうかを判断できるようなるためにはオブジェクトの種類を理解しておく必要があります。

#＃ Rubyのオブジェクト
Rubyには、以下のような種類のオブジェクトが存在ます。

一度に全て覚える必要はないですし、使っていくうちにだんだん覚えるものなので、最初は「こういうものがあるんだな」くらいの認識で大丈夫です。

さらっと確認してみてください。

|種類|オブジェクト名|
|---|---|
|整数|Fixnum|
|小数|Float|
|文字列|String|
|配列|Array|
|連想配列|Hash|
|true|TrueClass|
|false|FalseClass|
|nil(存在なし)|NilClass|


それぞれのオブジェクトは、実際には以下のように記述されます。

```ruby
# 整数:Fixnum
1
# 小数:Float
1.0
# 文字列:String
""文字列""
# 配列:Array
[1, 2, 3]
# 連想配列:Hash
{""key"" => ""value""}
# true:TrueClass
true
# false:FalseClass
false
# nil（存在なし:NilClass
nil
```

Rubyでは以上のようなオブジェクトの種類を意識する必要がありますが、今は「文字列」と「数字」だけ把握しておきましょう。

# p
`puts`の場合は出力されたデータがどのデータ型かわかりませんでした。しかし、`p`メソッドを利用すると、データ型の種類を確認することができます。

```ruby
p ""こんにちは""
p 1
```

実行結果

```
""こんにちは""
1
```

`puts`と`p`を比較してみると、`p`を利用するメリットがわかりやすいかと思います。

```
puts ""1""
p ""1""
```

実行結果

```
1
""1""
```

以上のように、`puts`で出力すると`1`という値が文字列なのか数字なのか判断できないのですが、`p`で出力するとそれが文字列だとわかります。このように、プログラムの中で使用されているデータがどのデータ型なのかを把握したい場合、`p`がとても役に立ちます。

# print
`print`は、改行を行わずに処理結果を表示するメソッドです。そこまで使用頻度は高くないので、特に意識して覚える必要はありません。`print`に関しては、`puts`と比較すると違いがわかりやすいので以下のコードを書いてみましょう。

```ruby
puts ""私の""
puts ""名前は""
puts ""神里です。""
puts ""-----------""
print ""私の""
print ""名前は""
print ""神里です。""
```

# 複数のデータを出力
`puts` `p` `print`に関しては、複数の値を出力させることも可能です。

```ruby
puts ""お"", ""は"", ""よ"", ""う""
p ""お"", ""は"", ""よ"", ""う""
print ""お"", ""は"", ""よ"", ""う""
```

実行結果

```
お
は
よ
う
""お""
""は""
""よ""
""う""
おはよう
```

# ヒアドキュメント
複数行の文字を出力したい場合、もちろん`puts`でも可能なのですが、ヒアドキュメントを使用するともっと楽になります。ヒアドキュメントの基本的な書き方は以下の通り。

```ruby
puts <<~TEXT
私の
名前は
神里です
TEXT
```

実行結果

```
私の
名前は
神里です
```

`puts`と比べると、ヒアドキュメントの方がはるかに楽なのがわかるかと思います。

```ruby
# putsを使用した場合
puts ""おはよう""
puts ""こんにちは""
puts ""こんばんは""

# ヒアドキュメントを使用した場合
puts <<~TEXT
おはよう
こんにちは
こんばんは
TEXT
```

実行結果

```
おはよう
こんにちは
こんばんは
おはよう
こんにちは
こんばんは
```

ちなみに、ヒアドキュメントを使用する際に文字列を`TEXT`で囲んでいるのですが、こちらは同じワードを使用して入れば記号以外ならなんでも大丈夫です。

```ruby
puts <<~TEXT
おはよう
こんにちは
こんばんは
TEXT

puts <<~亜亜亜
おはよう
こんにちは
こんばんは
亜亜亜

puts <<~あああ
おはよう
こんにちは
こんばんは
あああ

puts <<~aaa
おはよう
こんにちは
こんばんは
aaa

puts <<~111
おはよう
こんにちは
こんばんは
111
```

実行結果

```
おはよう
こんにちは
こんばんは
おはよう
こんにちは
こんばんは
おはよう
こんにちは
こんばんは
おはよう
こんにちは
こんばんは
おはよう
こんにちは
こんばんは
```

途中の改行も、ちゃんと反映されます。これを`puts`でやるとかなりめんどくさい。

```ruby
# putsを使用した場合（空文字で改行）
puts ""おはよう""
puts """"
puts ""こんにちは""
puts ""こんばんは""

# ヒアドキュメントを使用した場合（Enterで改行）
puts <<~TEXT
おはよう

こんにちは
こんばんは
TEXT
```

実行結果

```
おはよう

こんにちは
こんばんは
おはよう

こんにちは
こんばんは
```

以上のように、ヒアドキュメントを利用すると`puts`を連打するより複数行のデータ出力がかなり楽になります。

# まとめ
今回は、入出力に関して以下のメソッドについて学びました。

- puts
- p
- print

これらのメソッドは、現場でもいろんな場面で利用されます。うまく使いこなせれば開発が楽になるので、ぜひ使ってみてください。"
ruby,変数,"変数とは、値を入れておく箱のようなものです。この変数を使用すると、以下のようなメリットがあります。

- 値を使いまわせる
- 値を覚える必要がなくなる
- 変更に強いプログラムが組める

プログラムを組む上で、変数はかなり使用しますのでしっかりと理解しておきましょう。といっても、コードを書いていくうちに理解できるものなので、そこまで身構える必要はありません。

# 定義と代入
変数は、以下のように定義します。

```ruby
# name が変数
# ""satou"" が変数に格納する値
name = ""satou""
```

上のコードのように、`name`という入れ物を用意することで、`satou`という文字列が変数に格納されます。また、`name`の部分は自分の好きなように名前をつけてあげて大丈夫です。例えば、以下のようにいろんな変数を定義することができます。

```ruby
name = ""satou""
item = ""book""
price = 10000
```

# 式展開
変数の値を文字列の中で表示したい場合、以下のように記述します。

```ruby
name = ""Tanaka""

# 式展開を書くと表示される
puts ""Hello!! #{name}""

# そのまま変数名を書くと変数の値は表示されない
puts ""Hello!! name""
```

実行結果

```
Hello!! Tanaka
Hello!! name
```

また、式展開はヒアドキュメントの中で使用することもできます。

```ruby

name = ""Tanaka""

# ヒアドキュメントの中で式展開
puts <<~TEXT
Hello!! #{name}

You are very cool!!
Let's enjoy programming together!!
TEXT
```

# サンプルプログラム
では、変数を利用して、人の名前、年齢、住所、電話番号などの個人情報を表示するプログラムを書いてみましょう。

まずはファイルを作成します。テキストエディタを開いて「名前をつけて保存」を選択し、ファイル名を以下のようにして保存しましょう。`variable`は、「変数」という意味です。

```
variable.rb
```

ファイルが作成できたら、`variable.rb`にどんどんコードを追加していきます。

その際、随時`command + s(windowsは ctrl + s)`で上書き保存してから実行するようにしましょう。

記述したコードを実行するときは、以下のコマンドをターミナルから入力します。コー
ドが書けたら、このコマンドを実行して動作確認を行いましょう。

```
ruby variable.rb
```

それではさっそく、コードを書いていきます。

まずはそれぞれの変数を定義し、値を格納するところから。その際、どういうデータを格納する変数かがわかりやすいような変数名をつけてあげると、コードがグッと読みやすくなります。

```ruby
# 名前情報を入れる変数
name = ""Satou""
# 年齢情報を入れる変数
age = 33
# 住所情報を入れる変数
address = ""Tokyo""
# 電話番号を入れる変数
tell = ""080-2343-9183""
```

次に、それらの変数に格納した値を、式展開を用いてわかりやすい文章で表示してみましょう。

```ruby
# 名前情報を入れる変数
name = ""Satou""
# 年齢情報を入れる変数
age = 33
# 住所情報を入れる変数
address = ""Tokyo""
# 電話番号を入れる変数
tell = ""080-2343-9183""

# 変数に格納したデータを式展開で表示
puts ""【自己紹介】""
puts ""私の名前は#{name}です。""
puts ""年齢は#{age}です。""
puts ""今住んでいるところは#{address}です。""
puts ""電話番号は#{tell}です。""
puts ""宜しくお願いいたします！""
```

式展開で変数に格納したデータを表示することができたら、次はそれらのコードをヒアドキュメントに置き換えてリファクタリングしていきます。

ちなみに、リファクタリングとは、実行結果を変えずにコードを改善することです。これにより、コードの見通しや処理の効率が向上します。

```ruby
# 名前情報を入れる変数
name = ""Satou""
# 年齢情報を入れる変数
age = 33
# 住所情報を入れる変数
address = ""Tokyo""
# 電話番号を入れる変数
tell = ""080-2343-9183""

# ヒアドキュメントを使って式展開
puts <<~TEXT
【自己紹介】
私の名前は#{name}です。
年齢は#{age}です。
今住んでいるところは#{address}です。
電話番号は#{tell}です。
宜しくお願いいたします！
TEXT
```

# まとめ
変数はプログラミングの中でも使用する頻度がかなり高いです。これを使用することにより、コードの見通しが良くなったり、変更に強いプログラムを組むことができるようになります。

ぜひ、コードを書くときも、変数に置き換えられる箇所はないかを考えてみてください。"
ruby,条件分岐,"条件分岐とは、「もし〜だったら〜の処理をする」というように、条件によって行う処理を変えるために使用されるものです。条件分岐を実装するときには`if`や`unless`を使用します。ではさっそく、それぞれの使い方を学んでいきましょう。

## if
`if`の基本的な書き方は以下の通りとなります。

```ruby
hp = 10

if hp >= 10
  puts ""勇者のHPは10以上だ""
end
```

`if`の右側に書かれている`hp >= 10`が条件式となります。こちらの評価結果が成り立つ場合に、`if`と`end`で囲まれた部分の処理が実行されます。条件式にかかれている`>=`の部分は比較演算子と呼ばれ、以下のような種類があることを理解しておきましょう。

|比較演算子|意味|
|---|---|
|a >= b|aはb以上|
|a <= b|aはb以下|
|a > b|aはbより大きい|
|a < b|aはbより小さい|
|a == b|aはbと等しい|

比較演算子の中でも`a == b`の部分を`a = b`という風に`=`を1つ書き忘れることがよくあるので気をつけてください。それだと「代入」という意味になってしまいます。また、比較演算子は実行されると`true`か`false`が結果として返ってくることを理解しておきましょう。

それでは、以下の名前のファイル名を作成しましょう。

```
if_sample.rb
```

`if_sample.rb`が作成できたら、次のコードを書いてください。

```ruby
a = 10
b = 15

print ""aはb以上？：""
puts a >= b
print ""aはb以下？：""
puts a <= b
print ""aはbより大きい？：""
puts a > b
print ""aはbより小さい？：""
puts a < b
print ""aはbと同じ？：""
puts a == b
```

コードが記述できたら、以下のコマンドをターミナルから実行し、結果を確認してみましょう。

```
ruby if_sample.rb
```

実行結果

```
aはb以上？：false
aはb以下？：true
aはbより大きい？：false
aはbより小さい？：true
aはbと同じ？：false
```

`if`は比較演算子の評価結果が`true`になるか`false`になるかを判断し、行う処理を決めています。

そのため、以下のように記述してもエラーは表示されず、きちんと処理が実行されます。

```ruby
# 条件がtrueの場合は実行される
if true
  puts ""実行されます""
end

# 条件がfalseの場合は実行されない
if false
  puts ""実行されません""
end
```

実行結果

```
実行されます
```

このように、`if`の条件式に使用されている比較演算子では、評価結果として`true`か`false`かの判定が行われていることを理解しておいてください。

## else
`if`の部分に書いた条件式の評価結果が`false`のときに行いたい処理がある場合は`else`を使用します。

```ruby
hp = 5

if hp >= 10
  puts ""勇者のHPは10以上だ""
else
  # ifの条件が成り立たない場合の処理
  puts ""勇者のHPは10より下だ""
end
```

`else`を使用することによって、わざわざもう１つ`if`文を書かなくてもよくなり、コードがスマートになります。

以下が、ちょっとイマイチな例です。

```ruby
hp = 5

if hp >= 10
  puts ""勇者のHPは10以上だ""
end

if hp < 10
  puts ""勇者のHPは10より下だ""
end
```

`if`をわざわざ２つ書いているので、表現が冗長ですね。このような場合は、`else`を使った方がスッキリします。

## elsif
`elsif`は`if`の部分に加え、さらに条件を追加したいときに使用します。

`elseif`ではなく、`elsif`だということに注意してくださいね！

```ruby
hp = 3

if hp > 10
  puts ""勇者は元気だ""
# 複数の条件を指定するときに使う
elsif hp > 5
  puts ""勇者は弱っている""
elsif hp > 3
  puts ""勇者はかなり弱っている""
elsif hp > 0
  puts ""勇者は瀕死だ""
else
  puts ""勇者はしんだ""
end
```

この`elsif`も、複数条件で処理を行いたいときに、冗長な表現を避けることができます。

ちなみに、`elsif`を使わないとこんな感じになります。

```ruby
hp = 3

if hp > 10
  puts ""勇者はピンピンしている""
end

if hp > 10
  puts ""勇者は元気だ""
end

if hp > 5
  puts ""勇者は弱っている""
end

if hp > 3
  puts ""勇者はかなり弱っている""
end

if hp > 0
  puts ""勇者は瀕死だ""
end

if hp <= 0
  puts ""勇者はしんだ""
end
```

うん、超めんどくさい！笑

ちなみに、条件がたくさんあり、かつ、「〜と〜が等しい」みたいな条件を判定する場合は、`case`を使うこともあります。

|文法|特徴|
|---|---|
|if|~以上、~以下と行った判定ができる|
|case|1つの比較対象に対して複数の条件分岐を行う|

以下が、`case`の使用例です。

```ruby
month = 6

# 比較対象をcaseの後に記述
case month
# 比較対象と比較する値を記述
when 3, 4, 5
  puts ""春です""
when 6, 7, 8
  puts ""夏です""
when 9, 10, 11
  puts ""秋です""
when 12, 1, 2
  puts ""冬です""
else
　puts ""不正な値です""
end
```

ちなみに、この`case`に対しても、条件判定の部分で範囲オブジェクト（`3..5`など）を使用できます。

```ruby
month = 6

# 比較対象をcaseの後に記述
case month
# 比較対象と比較する値を記述
when 3..5
  puts ""春です""
when 6..8
  puts ""夏です""
when 9..11
  puts ""秋です""
when 12..2
  puts ""冬です""
else
　puts ""不正な値です""
end
```

実行結果

```
夏です
```

# ifの省略形
実は、`if`は1行で書くこともできます。条件を１つしか判定しない場合はこのほうがスッキリするので、意識して使うようにして見てください。実際に現場でもこの使い方はよく見ます。

```ruby
# 省略形
puts ""勇者のHPは10以上だ"" if hp >= 10
```

## 三項演算子
見慣れていない方はちょっと混乱されるかもしれませんが、条件分岐には`三項演算子`というものも存在します。ちょっと書き方は複雑ですが、こちらも現場ではよく用いられるものなので、使えるように意識してみてください。

```ruby
hp = 11

# 条件式(true or false) ? trueの時に行いたい処理 : falseの時に行いたい処理
puts hp > 10 ? ""勇者のHPは10より大きいです"" : ""勇者のHPは10より小さいです""
```

# サンプルプログラム
それでは、`if`を利用したサンプルプログラムを作っていきましょう！

まずは、以下のような名前のファイルを作成し、保存します。

```
conditional.rb
```

それでは、`conditional.rb`にコードを書いていきましょう。今回は、`if`を使用して戦闘ゲームを再現していきます。

まずは、それぞれのキャラクターのパラメータを変数に入れましょう！慣れない人は、`#`でコメントも書いておくと、後から見返したときに理解しやすいです。

```ruby
# 勇者のhp
brave_hp = 30
# 勇者の攻撃力
brave_attack = 10
# 勇者の防御力
brave_defense = 5
# 敵のhp
enemy_hp = 30
# 敵の攻撃力
enemy_attack = 5
# 敵の防御力
enemy_defense = 10
```

それでは次に、キャラクターが攻撃をするときの処理を書いていきましょう。

```ruby
brave_hp = 30
brave_attack = 10
brave_defense = 5

enemy_hp = 30
enemy_attack = 5
enemy_defense = 10

# 敵に与えるダメージの計算
enemy_damage = brave_attack - enemy_defense
```

敵に与えるダメージの計算ができたら、それを敵のHPから引き算してダメージを与える処理を書きます。

```ruby
brave_hp = 30
brave_attack = 10
brave_defense = 5

enemy_hp = 30
enemy_attack = 5
enemy_defense = 10

enemy_damage = brave_attack - enemy_defense
# 敵のHPにダメージを与える
enemy_hp = enemy_hp - enemy_damage
```

敵にダメージを与えるコードが追加できたら、`if`を利用して、残りHPによって敵キャラのリアクションを変えるようにしましょう！

```ruby
brave_hp = 30
brave_attack = 10
brave_defense = 5

enemy_hp = 30
enemy_attack = 5
enemy_defense = 10

enemy_damage = brave_attack - enemy_defense
enemy_hp = enemy_hp - enemy_damage

# 敵に与えるダメージと残りHPの表示
puts ""敵に#{enemy_damage}のダメージを与えた。""
puts ""残りHPは#{enemy_hp}だ。""

# 残りHPによってリアクションを変える
if enemy_hp > 20
  puts ""敵は元気だ""
elsif enemy_hp > 10
  puts ""敵はちょっと弱っている""
elsif enemy_hp > 5
  puts ""敵はかなり弱っている""
elsif enemy_hp > 0
  puts ""敵は瀕死だ""
else
  puts ""敵はしんだ""
end
```

それでは同様に、敵から勇者へ攻撃を行うときの処理も追加していきましょう！できるひとは、サンプルコードを見ずに自分で考えてコードを書いて見てください。自分で考えてコードを書くと、かなり勉強になりますよ。

```ruby
brave_hp = 30
brave_attack = 10
brave_defense = 5

enemy_hp = 30
enemy_attack = 5
enemy_defense = 10

enemy_damage = brave_attack - enemy_defense
enemy_hp = enemy_hp - enemy_damage

puts ""敵に#{enemy_damage}のダメージを与えた。""
puts ""残りHPは#{enemy_hp}だ。""

if enemy_hp > 20
  puts ""敵は元気だ""
elsif enemy_hp > 10
  puts ""敵はちょっと弱っている""
elsif enemy_hp > 5
  puts ""敵はかなり弱っている""
elsif enemy_hp > 0
  puts ""敵は瀕死だ""
else
  puts ""敵はしんだ""
end


# 敵に与えるダメージの計算
brave_damage = enemy_attack - brave_defense
# 敵のHPにダメージを与える
brave_hp = brave_hp - brave_damage

# 敵に与えるダメージと残りHPの表示
puts ""敵から#{brave_damage}のダメージを受けた。""
puts ""残りHPは#{brave_hp}だ。""

# 残りHPによってリアクションを変える
if brave_hp > 20
  puts ""勇者は元気だ""
elsif brave_hp > 10
  puts ""勇者はちょっと弱っている""
elsif brave_hp > 5
  puts ""勇者はかなり弱っている""
elsif brave_hp > 0
  puts ""勇者は瀕死だ""
else
  puts ""勇者は死んだ""
end
```

コードを書いたら、プログラムを実行して動作確認してみましょう。
エラーが表示されていなければ完成です。

以上で簡単なゲームの再現はできました。
しかし、こちらのコードにはまだまだ改善の余地があります。

では、これからサンプルコードを改善（リファクタリング）していきましょう。

まずは、ヒアドキュメントを使用し、`puts`を使用している部分をもう少しスッキリ記述できるようにします。

```ruby
brave_hp = 30
brave_attack = 10
brave_defense = 5

enemy_hp = 30
enemy_attack = 5
enemy_defense = 10

enemy_damage = brave_attack - enemy_defense
enemy_hp = enemy_hp - enemy_damage

# ヒアドキュメント
puts <<~TEXT
敵に#{enemy_damage}のダメージを与えた。
残りHPは#{enemy_hp}だ。
TEXT

if enemy_hp > 20
  puts ""敵は元気だ""
elsif enemy_hp > 10
  puts ""敵はちょっと弱っている""
elsif enemy_hp > 5
  puts ""敵はかなり弱っている""
elsif enemy_hp > 0
  puts ""敵は瀕死だ""
else
  puts ""敵は死んだ""
end

brave_damage = enemy_attack - brave_defense
brave_hp = brave_hp - brave_damage

# 敵に与えるダメージと残りHPの表示
puts <<~TEXT
敵から#{brave_damage}のダメージを受けた。
残りHPは#{brave_hp}だ。
TEXT

# 残りHPによってリアクションを変える
if brave_hp > 20
  puts ""勇者は元気だ""
elsif brave_hp > 10
  puts ""勇者はちょっと弱っている""
elsif brave_hp > 5
  puts ""勇者はかなり弱っている""
elsif brave_hp > 0
  puts ""勇者は瀕死だ""
else
  puts ""勇者はしんだ""
end
```

これで、表示の部分はスッキリさせることができました。

他に、もう１つ改善点としてあげられるのは、攻撃の処理において決まった値しか計算されないことです。
これではゲーム性がないので、次に、与えるダメージがある一定の範囲で変化するような処理を書いて見ましょう。

この処理を実装するときには`rand`というメソッドを使います。

この`rand`は、数字を指定するとその中からランダムな値を表示してくれます。これを利用して、攻撃の処理をするさいのダメージを変化するように実装して見ましょう。

その際、`3..5`といった`範囲オブジェクト（Range）`というものを使用して`rand`を記述すると、指定した範囲の中でランダムな値を表示してくれるようになります。

```ruby
brave_hp = 30
brave_attack = 10
brave_defense = 5

enemy_hp = 30
enemy_attack = 5
enemy_defense = 10

# 攻撃にランダム要素を入れる
# 範囲オブジェクト　3..5
enemy_damage = brave_attack - enemy_defense + rand(3..5)
enemy_hp = enemy_hp - enemy_damage

puts <<~TEXT
敵に#{enemy_damage}のダメージを与えた。
残りHPは#{enemy_hp}だ。
TEXT

if enemy_hp > 20
  puts ""敵は元気だ""
elsif enemy_hp > 10
  puts ""敵はちょっと弱っている""
elsif enemy_hp > 5
  puts ""敵はかなり弱っている""
elsif enemy_hp > 0
  puts ""敵は瀕死だ""
else
  puts ""敵はしんだ""
end

# 攻撃にランダム要素を入れる
# 範囲オブジェクト　3..5
brave_damage = enemy_attack - brave_defense + rand(3..5)
brave_hp = brave_hp - brave_damage

puts <<~TEXT
敵から#{brave_damage}のダメージを受けた。
残りHPは#{brave_hp}だ。
TEXT

if brave_hp > 20
  puts ""勇者は元気だ""
elsif brave_hp > 10
  puts ""勇者はちょっと弱っている""
elsif brave_hp > 5
  puts ""勇者はかなり弱っている""
elsif brave_hp > 0
  puts ""勇者は瀕死だ""
else
  puts ""勇者はしんだ""
end
```

また、`rand`を使用すれば通常攻撃とクリティカルヒットをランダムに発生させることもできます。その際、`rand(4)`とかくと`0~3`のうちでランダムな数字を発生させることができます（1~4ではないことに注意してください）

```ruby
brave_hp = 30
brave_attack = 10
brave_defense = 5

enemy_hp = 30
enemy_attack = 5
enemy_defense = 10

# 攻撃にランダム要素を入れる
# rand(4)にすると0~3のうちランダムに数字を発生させる
select_attack = rand(4)

if select_attack == 0
  puts ""かいしんのいちげき""
  # randの範囲を20~30と大きな値にする
  enemy_damage = brave_attack - enemy_defense + rand(20..30)
  enemy_hp = enemy_hp - enemy_damage
else
  puts ""つうじょうこうげき""
  enemy_damage = brave_attack - enemy_defense + rand(3..5)
  enemy_hp = enemy_hp - enemy_damage
end

puts <<~TEXT
敵に#{enemy_damage}のダメージを与えた。
残りHPは#{enemy_hp}だ。
TEXT

if enemy_hp > 20
  puts ""敵は元気だ""
elsif enemy_hp > 10
  puts ""敵はちょっと弱っている""
elsif enemy_hp > 5
  puts ""敵はかなり弱っている""
elsif enemy_hp > 0
  puts ""敵は瀕死だ""
else
  puts ""敵はしんだ""
end

# 攻撃にランダム要素を入れる
# rand(4)にすると0~3のうちランダムに数字を発生させる
select_attack = rand(4)

if select_attack == 0
  puts ""かいしんのいちげき""
  # randの範囲を20~30と大きな値にする
  brave_damage = enemy_attack - brave_defense + rand(10..20)
  brave_hp = brave_hp - brave_damage
else
  puts ""つうじょうこうげき""
  brave_damage = enemy_attack - brave_defense + rand(3..5)
  brave_hp = brave_hp - brave_damage
end

puts <<~TEXT
敵から#{brave_damage}のダメージを受けた。
残りHPは#{brave_hp}だ。
TEXT

if brave_hp > 20
  puts ""勇者は元気だ""
elsif brave_hp > 10
  puts ""勇者はちょっと弱っている""
elsif brave_hp > 5
  puts ""勇者はかなり弱っている""
elsif brave_hp > 0
  puts ""勇者は瀕死だ""
else
  puts ""勇者はしんだ""
end
```

これでだいぶリファクタリングができました。他にも自分なりに工夫できる部分はあるかと思いますので、ぜひこちらのコードをカスタマイズしてオリジナルプログラムを組んでみてください。

# まとめ
`if`が使えるようになると、行える処理もかなり柔軟になります。現場でもよく使用するので、`if`を使って無駄なく柔軟にプログラムを書く練習をなんどもやってみてください。

お疲れ様でした！"
ruby,メソッド,"メソッドとは一言で言うと「処理のかたまり」です。

例えば、「選んだ商品と購入する数によって合計金額を計算する」とか「入力したIDとパスワードを判定してログインできるかどうかを判定する」などの一連の処理をまとめ、プログラムの中でいつでもどこでも簡単に必要な処理を呼び出せるようにしたものです。

とはいっても、実際にメソッドを利用してみないとイメージがわかないので、さっそくメソッドを定義してみましょう。

# メソッドの定義と使い方
メソッドの定義は以下のようになります。

```ruby
def メソッド名

end
```

「メソッド名」の部分には、任意の名前をつけてあげます。

大体の場合は、「どう言う処理を行うメソッドか？」と言うことがわかりやすいように、動詞で名前をつけてあげます。

それでは、「選んだ商品と購入する数によって合計金額を計算するメソッド」を定義していきましょう。

まず、メソッド名は以下のようにします。

```ruby
# 合計金額を表示するメソッド
def disp_sum

end
```

以上で `disp_sum` という名前のメソッドが定義できました。

それでは、 `disp_sum` の中に具体的な処理を書いていきましょう。

```ruby
def disp_sum

  # 商品の値段(price)と個数(num)
  price = 1980
  num = 20

  # 商品の合計購入金額を計算
  price * num

end
```

メソッドの定義が終わったら、さっそくメソッドを呼び出してみましょう。

呼び出す際は以下のように記述します。

```ruby
def disp_sum

  price = 1980
  num = 20

  price * num

end

puts disp_sum
```

実行結果

```
39600
```

これではちょっと味気ないので、式展開を使って意味がわかりやすいような表示にしてみましょう。

```ruby
def disp_sum

  price = 1980
  num = 20

  ""#{price}円の商品を#{num}個買ったので、合計金額は#{price * num}です""

end

puts disp_sum
```

実行結果

```
1980円の商品を20個買ったので、合計金額は39600です
```

Rubyにおいて、メソッドは最後に評価した値を呼び出し元に戻します。

先ほどのコードにおいて呼び出し元とは `puts disp_sum` の部分です。

この部分に、メソッドの最後に実行された `price * num` の値が返ってきます。

そのため、 `price * num` の計算結果である `39600` という値が返ってきたわけです。

ちなみに、以下のようにメソッドの中に `return` を加えても同じように処理ができます。


```ruby
def disp_sum

  price = 1980
  num = 20

  # return を記述
  return ""#{price}円の商品を#{num}個買ったので、合計金額は#{price * num}です""

end

puts disp_sum
```

実行結果

```
1980円の商品を20個買ったので、合計金額は39600です
```

このようにメソッドの中では `return` を記述しても `price * num` の実行結果を呼び出し元である `puts disp_sum` の部分に返すことができます。

また、他の言語でも同様にメソッドの中では戻り値を返すためによく `return` を使用します。

しかし、Rubyのメソッドでは、先ほども説明したように最後に評価した値を呼び出し元に返してくれます。

そのため、ほとんどの場合メソッドの中には `return` を記述しません。

`return` を使うのは、メソッドの途中で処理を抜けたいときです。

例えば、以下の場合をみてみましょう。

```ruby
def disp_sum

  price = 1980
  num = -1

  # return を記述
  return ""商品の購入数は0以上にしてください"" if num <= 0

  ""#{price}円の商品を#{num}個買ったので、合計金額は#{price * num}です""

end

puts disp_sum
```

実行結果

```
商品の購入数は0以上にしてください
```

このように、メソッドの途中で処理を抜けたい場合に `if` などの条件分岐と合わせて使用することがよくあります。

この使い方を覚えておくと、現場でも役に立つことがありますよ。

# メソッドの引数
メソッドには「引数」という処理の材料を渡すことができます。

この引数を使用することにより、より柔軟な処理ができるようになります。

では、以下のコードを例に説明していきましょう。

```ruby
def disp_sum

  price = 1980
  num = 20

  return ""商品の購入数は0以上にしてください"" if num <= 0

  ""#{price}円の商品を#{num}個買ったので、合計金額は#{price * num}です""

end

puts disp_sum
```

上のコードでは、何度実行しても `price` の値は `1980` で、 `num` の値は `20` の計算しかできません。これでは、全く柔軟性のないメソッドになってしまいますね。

しかし、このメソッドに引数を使えば、とても柔軟に値の計算ができるようになります。

それではさっそく、引数を使ったメソッドを定義していきましょう。

```ruby
# ()の中のprice, numが引数を受け取る変数
def disp_sum(price, num)

  return ""商品の購入数は0以上にしてください"" if num <= 0

  ""#{price}円の商品を#{num}個買ったので、合計金額は#{price * num}です""

end

# ()の中の値がdisp_sumの引数：左からprice, numの順番となる
puts disp_sum(1980, 20)
puts disp_sum(2480, 20)
puts disp_sum(72980, 20)
```

実行結果

```
1980円の商品を20個買ったので、合計金額は39600です
2480円の商品を20個買ったので、合計金額は49600です
72980円の商品を20個買ったので、合計金額は1459600です
```

これでかなり柔軟に計算ができるようになりましたね。

`disp_sum(1980, 20)` や `puts disp_sum(2480, 20)` のように、引数に渡してあげる値を変えれば、それに応じて柔軟に計算結果を変えることができます。

また、試しに `num` の部分に入る数を `-1` にしてみましょう。

```ruby
def disp_sum(price, num)

  return ""商品の購入数は0以上にしてください"" if num <= 0

  ""#{price}円の商品を#{num}個買ったので、合計金額は#{price * num}です""

end

# 引数を-1にする
puts disp_sum(1980, -1)
```

実行結果

```
商品の購入数は0以上にしてください
```

`num` の引数を `-1` にすると、きちんと注意文が表示されました。

この注意文に関しても、入力した値が表示されるようにちょっと改善しましょう。

```ruby
def disp_sum(price, num)

  return ""商品の購入数は0以上にしてください：入力値 #{num}"" if num <= 0

  ""#{price}円の商品を#{num}個買ったので、合計金額は#{price * num}です""

end

# 引数を-1にする
puts disp_sum(1980, -1)
```

実行結果

```
商品の購入数は0以上にしてください：入力値 -1
```

このように、引数を使用するとだいぶ処理の柔軟性が出てきます。

# デフォルト値付きの引数
先ほど引数付きのメソッドを定義する方法を学びました。

しかし、メソッドに引数を設定した場合、呼び出し元で引数を渡してあげないとエラーが出ます。

```ruby
def disp_sum(price, num)

  return ""商品の購入数は0以上にしてください：入力値 #{num}"" if num <= 0

  ""#{price}円の商品を#{num}個買ったので、合計金額は#{price * num}です""

end

# 引数を無しにしてメソッドを呼び出し
puts disp_sum()
```

実行結果

```
ArgumentError (wrong number of arguments (given 0, expected 2))
```

これだと、引数に渡すデータが存在しない場合にはプログラムが途中で止まってしまいます。

しかし、Rubyのメソッドにはこのようなエラーを防ぐための仕組みがあります。

それが、引数のデフォルト値の設定です。

引数にデフォルト値を設定すると、「引数が存在する場合は引数を元に処理を行い、引数がない場合はデフォルト値を使って処理を行う」といった処理が可能になります。

引数に対するデフォルト値は以下のように設定することができます。

```ruby
# 引数にデフォルト値を設定
def disp_sum(price = 1980, num = 20)

  return ""商品の購入数は0以上にしてください：入力値 #{num}"" if num <= 0

  ""#{price}円の商品を#{num}個買ったので、合計金額は#{price * num}です""

end
# 引数を無しにしてメソッドを呼び出し
puts disp_sum()
```

実行結果

```
1980円の商品を20個買ったので、合計金額は39600です
```

このように、引数にデフォルト値を設定すると、呼び出し元で引数を渡さなかったとしてもエラーが表示されなくなります。

こちらも現場ではよく使う書き方なのでぜひ、使えるようにしておいてください。


# まとめ
メソッドは、効率よく複雑な処理を実装するためによく利用されます。

このメソッドの中でいかに効率の良い処理をかけるかどうかがプログラマーの腕の見せ所です。

メソッドの定義や使い方をしっかりと覚え、かつ、ほかの文法とどうやって組み合わせるかを常に考える癖をつけてみてください。

そうすることで、シンプルで効率の良い処理を素早く実装できるプログラマーになることができます。"
rails,Ruby on Rails の基本,"こちらでは、コードを書くのではなくRuby on Railsがどういうものなのかを説明することに焦点を当てます。今後、Ruby on Railsのスキルを身につける上で、基本的な仕組みを知っておくことは超重要。基礎の基礎が大事ということをよく頭に入れながら学んでいきましょう。

# MVC
Ruby on Railsは、MVCアーキテクチャにのっとって設計されています。そのため、MVCアーキテクチャを理解しておくことがとても重要になって来るのです。ちなみに、MVCのそれぞれの意味はM（モデル）、V（ビュー）、C（コントローラー）となります。そして、これらの要素はRuby on Railsにおいて明確に役割が決まっています。

|名前|役割|
|---|---|
|M(モデル)|データベースのデータを扱う、複雑なロジックを組む|
|V(ビュー)|Webサイトの画面を構成|
|C(コントローラー)|処理の振り分け|

# Ruby on Railsの構成要素
Ruby on Railsには、様々な構成要素があります。そのなかでも、まずは基本となる以下の構成要素を覚えておきましょう。

1. Active Record（モデル）
2. Action View（ビュー）
3. Action Controller（コントローラー）

# Ruby on Railsの便利な機能
Ruby on Railsがなぜ便利なのか？その秘密がこちらです。

## ルーティング
&や=、拡張子の入った汚いURLではなく、`/user/1`などの綺麗でなんのデータを見ているのかわかりやすいURLを使用することができます。

## テンプレート
Ruby on Railsでは、Webサイトのナビゲーションバーなどを全体で共有したり、HTMLの中に直接Rubyのコードを埋め込んだりすることができます。これにより、同じコードをなんども書く手間が省けたり、柔軟に画面の表示を変えることが可能になるわけです。

## マイグレーション
マイグレーションとはデータベースのテーブルを定義するための機能で、この機能によりデータベースを操作するための言語であるSQLを直接書かなくても自由にテーブルを作成できるようになります

## レコードの操作
データベースに保存されているデータのかたまり（レコード）を簡単に操作することができます。これにより、データの一覧表示、登録、更新、削除といったデータを扱うための操作（CRUD処理）が実現しやすくなっています。

## バリデーション
データベースのテーブルにデータを保存するときに、データのチェックを行うことができます。例えば、数字になっているか？空のデータになっていないか？データが長すぎないか？といったチェックを簡単に行えるようになるわけです。

## 国際化
様々な言語に対応したWebサイトを構築することができます。

## テスト
Webサイトの品質を保つのに重要なテストが簡単に実装できます。

## セッション
複数ページにまたがって、同一ユーザーのデータを保持する（例：アマゾンのショッピングカート）といった機能が簡単に実現できます。

## モデル間の関連付け
複数のモデル間で連携し、データの検索を行う際にいちどに複数のテーブルのデータを取り出すことが可能になります。例えば、あるユーザーの購入した商品一覧を表示するときにも、この関連付けが役に立ちます。

# HTTP
 HTTPは、ブラウザとサーバーがHTML、画像などの情報をやり取りするときに使われる通信手段（プロトコル）です。Webサイトを作成する際にも、この点を理解しながら進めていきましょう。

## リクエストとレスポンス
Webサイトではリクエストとレスポンスによって情報の送受信が行われています。リクエストは、ユーザーがブラウザから要求するもので、レスポンスはユーザーの要求に応じて必要なデータを返すことです。このやりとりによって、Webサイトはユーザーに必要な情報を届けることができています。

|名前|意味|
|---|---|
|リクエスト|ユーザーがサーバーに対してデータを要求すること|
|レスポンス|ユーザーのリクエストに応じた情報をサーバーが返すこと|

# Ruby on Railsのリクエストの流れ
Webアプリケーションを作成するにあたって、リクエストの流れを理解することは超重要です。今後の学習をスムーズに進めるためにも、この流れをよく理解しておきましょう。Ruby on Railsにおいて、ユーザーからのリクエストは以下の流れで処理されます。

1. ルート
2. コントローラ
3. ビュー

Ruby on Railsはブラウザからのリクエストを受け取ると、`config`ディレクトリの中にある`routes.rb`の記述に従ってどのコントローラのどのアクションに処理を渡すかを決めます。

コントローラは複数あり、そのコントローラの中に複数のアクションがあります。そして、アクションにはモデルとどのようなやり取りをするのかを記述します。また、モデルから取り出したデータはインスタンス変数に保存し、その情報をビューに渡します。アクションは、ブラウザへのレスポンスを作成するために、表示するビューを選択します。特に指定がない場合は、アクションと同じ名前のビューが選択されて、ブラウザに表示されます。

このコントローラによって、モデルからデータを受け取ったり、次にどのビューを表示させるかを決めたりすることができるわけです。

コントローラによって選ばれたビュー（テンプレートともいう）は、コントローラのインスタンス変数を参照して、その値をHTMLの中で使用することができます。それにより、ユーザーが要求したデータを柔軟に表示させることができるわけです。"
rails,Ruby on Rails の環境構築,"Ruby on Railsとは、Rubyを利用して効率よくWebサイトを開発できるようにしてくれるものです。このRailsのように、Webアプリケーションの開発効率をあげてくれるものを「フレームワーク」と言います。今回の学習ではRailsを使用することはありませんが、将来、Webアプリケーションを開発する上で必要になるものなので、ついでに環境構築していきましょう。

## インストールの流れ
環境構築は以下の手順で行います。

1. Xcodeのインストール
2. Command Line Tools
3. Homebrew
4. rbenv(アールベンブ), ruby-build(ルビー・ビルド)
5. readline
6. MySQL
7. bundler
8. Ruby on Rails

## Xcodeのインストール
まずは`AppStore`にて`Xcode`のインストールを行いましょう。`AppStore`は、Macのアプリをインストールするためのプラットフォームです。以下の手順でXcodeをダウンロードしましょう。

1. Finderを開く
2. 「アプリケーション」に移動
3. AppStoreを開く
4. 「Xcode」と検索
5. Xcodeをダウンロード

## Commandlinetoolのインストール
次に、[AppleのDevelopperサイト](https://developer.apple.com/download/more/)から`Command LineTool`をインストールします。もし、認証チェック画面が出たら、以下の手順を実行しましょう。認証チェックが表示されない場合は、4番と5番を実行してください。

1. チェックボックスにチェックしてsubmit
2. download tools
3. see more downloads
4. 左上の検索窓で`command`と入力して検索
5. 自分のOSのバージョンにあった`Command LineTool`をインストール。

## Homebrewのインストール
Homebrewのインストールをします。ここからはターミナルでコマンドを入力していきましょう。ターミナルの場所は「アプリケーション＞ユーティリティ＞ターミナル」となります。ターミナルを開いたら、以下のコマンドを入力しましょう。

```
$ ruby -e ""$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)""
```

途中で`enter`を求められるので`enterキー`を押し、その後、Macのパスワードを入力しましょう。インストールが終了すると、ターミナルからコマンド入力できる状態に戻ります。その後、homebrewがきちんとインストールできたか確かめるため、以下のコマンドを入力します。こちらは、Homebrewのバージョンを確認するコマンドです。

```
$ brew -v
```

以下のようにバージョン情報が表示されればOKです。（バージョンの数字は異なっていても構いません）

```
Homebrew 2.1.8
Homebrew/homebrew-core (git revision 03c4; last commit 2019-07-27)
```

## 権限の変更
Railsをインストーする際、関連ディレクトリの権限エラーが出ることがあるので、`/usr/local/bin`フォルダの所有者をadminユーザーに変更します。その際は以下のようなコマンドを入力します。

```
$ sudo chown -R `whoami`:admin /usr/local/bin
```

`chown`はファイルやディレクトリの所有者を、コマンドで指定したユーザーに変更するコマンドです。`-R`というオプションをつけると、指定したディレクトリとそのディレクトリ以下のファイルやディレクトリの所有権を再帰的に変更します。

```
$ chown [オプション] [ユーザー:グループ] [ファイルorディレクトリ]
```

`whoami`は自分のユーザー名を表示するコマンドです。

```
$ whoami
```

## rbenv(アールベンブ), ruby-build(ルビー・ビルド)のインストール
次に、rbenv(アールベンブ), ruby-build(ルビー・ビルド)をインストールしましょう。ruby-buildはRubyの様々なバージョン(2.4.1など)をインストールすることができるツールで、rbenvは、rubyのバージョンを切り替えるためのツールです。

インストールはHomebrewを使用して行います。以下のコマンドを実行して`rbenv`と`ruby-build`をインストールしましょう。

```
$ brew install rbenv ruby-build
```

インストールが完了したら、rbenvのパスを通します。

```
$ echo 'eval ""$(rbenv init -)""' >> ~/.bash_profile
```

bash_profileの変更内容を読み込む

```
$ source ~/.bash_profile
```

以下のコマンドで、 `rbenv`と`ruby-build`がインストールされていることを確認しましょう。バージョンが表示されれば成功です。

```
$ rbenv -v
$ ruby-build --version
```

## readlineのinstall
readlineはCUIでの操作を簡単にするためのツールです。こちらのライブラリを使うことで、ユーザがコマンドを入力する際に「行頭・行末移動」「ヒストリ機能」などを簡単なコマンドで実行することができます。また、Rubyでデバッグを行うときに使用する`irb`や`pry`起動時に、日本語の文字化けを防ぐことができます。

```
$ pry
[1] pry(main)> 'ぷらい'
=> ""ぷらい""

$ irb
irb(main):001:0> 'あいあーるびー'
=> ""あいあーるびー""
```

それではさっそく、`readline`をインストールしましょう。

```
$ brew install readline
```

インストールが終わったら、readlineのパスを通します。

```
$ brew link readline --force
```

僕がよく使う`readline`のコマンドは以下の2つです。この２つを利用すると、ターミナルでコマンド入力時に、瞬時に行頭・行末に移動することができます。

|操作|コマンド|
|---|---|
|行頭に移動|control + a|
|行末に移動|control + e|

## Rubyのインストール
rbenvを利用して`Ruby`のインストールを行います。

```
$ RUBY_CONFIGURE_OPTS=""--with-readline-dir=$(brew --prefix readline)""
```

```
$ rbenv install 2.6.0
```

インストールが完了したらリハッシュします。

```
$ rbenv rehash
```

rbenvを用いて利用するRubyのバージョンを決めます。

```
$ rbenv global 2.6.0
```

Rubyのバージョンを確認し、インストールが成功しているか確かめましょう。

```
ruby -v
```

## bundlerのインストール
次に、Rubyのgemであるbundlerをインストールします。

```
$ gem install bundler
```

## Ruby on Railsのインストール
次にRubyのgemでありフレームワークでもある`Ruby on Rails`をインストールします。

```
$ gem install rails
```

gemをインストールしたのでrehashを行います。

```
$ rbenv rehash
```

インストールがうまくいったかどうか確かめるため、以下のコマンドを入力してRailsのバージョンを確認しましょう。きちんとバージョンが表示されればインストールは成功です。

```
$ rails -v
```"
rails,Ruby on Rails で Hello World!!,"こちらでは、Railsを使って「Hello World」を表示する簡単なWebアプリケーションを作っていきましょう。

# Webアプリケーションとは
WEBアプリケーションとは、ブラウザから利用可能な動的なWebサービスのことを指します。

動的Webサービスとは何かというと、ユーザーの利用状況によって柔軟に画面や表示内容が変わるサービスのことです。例えば、会社のホームページとFacebookやTwitterなどを比べてみるとよくわかるかとお思います。

会社のホームページは何度訪れても画面になんの変化もありません。それに対し、FacebookやTwitterはユーザの登録情報や投稿内容によってまったく表示が異なります。このように、動的に変化するのがWebアプリケーションの特徴です。

# リクエストとレスポンス
Webでは、リクエストとレスポンスという概念が存在します。`リクエスト`はユーザーからの要求のことで、ボタンをクリックしたり、URLを入力してアクセスしたときにリクエストが発生します。`レスポンス`はサーバーの応答のことで、ユーザーが要求したデータを表示するときにサーバーからレスポンスが送信されます。

- ユーザの要求 => リクエスト
- アプリの応答 => レスポンス

# Railsアプリの構成
Railsアプリの構成は、初心者にとってはかなり複雑な印象があるかと思います。でも、きちんと以下の構成になっていることを頭に入れておけば、この後の学習もだいぶスムーズになるので、よく確認して見てください。

- Rails（アプリの本体）
 - ルート（コントローラへの処理の振り分け）
 - コントローラ（モデルやビューへの処理の振り分け）
 - モデル（ロジックの定義）
 - ビュー（）
- データベース（MySQL, Postgre, SQLiteなど）

# 今回作成するアプリ
今回作成するのは、`Hello World`を表示するだけの簡単なアプリです。このアプリを通して、ルート・コントローラ・ビューの作成方法をしっかりと身につけましょう。

このレッスンの内容が、これからRailsアプリケーションを作成するための土台となります。大切な部分なので、一つ一つ確認しながら進めていってください。

# Railsアプリの処理の順番
Railsアプリにユーザーからアクセスがあった場合、アプリ内で以下のように処理されます。

1. リクエスト：ユーザーからのリクエスト
2. ルート：指定されたURLに応じたコントローラのアクションを指定
3. コントローラ：モデルやビューへの処理の振り分け
4. ビュー：画面の表示

この流れに応じて処理を書いていくので、しっかりと頭に入れて置いてください。それではさっそく、アプリを立ち上げましょう。

# アプリ立ち上げの流れ
アプリ立ち上げの流れは以下のようになります。これから実際に手を動かしながら確認して行きましょう。慣れないうちは、アプリを立ち上げたら毎回以下の流れで手順5まで実行し、初期画面が表示されるか確認してください。

1. `rails new`コマンドを実行しアプリのディレクトリを作成
2. `cd`コマンドを使って立ち上げたアプリのディレクトリに移動
3. `rake db:create`（データベースの作成）
4. `rails s`（サーバを立ち上げ）
5. [http://localhost:3000/](http://localhost:3000/)にアクセス

## アプリの立ち上げ
アプリを立ち上げる時は、ますはアプリを作成したいディレクトリに移動します。今回、例として`projects`配下でアプリを立ち上げることを前提に進めていきます。`projects`ディレクトリを作成したら、`cd`コマンドを用いてその中に移動します。

```
cd projects
```

念の為、`pwd`コマンドを使ってきちんと移動できているか確かめましょう。`projects`のパスが表示されればOKです。

```
/homes/yoshito/projects
```

`projects`ディレクトリに移動できたら、以下のようにコマンドを実行しアプリを立ち上げます。その際、`rails new`の後に`hello_world_sample`と指定することで、その名前のアプリを作成できます。

```
rails new hello_world_sample
```

そうすると、`sample`という名前のディレクトリが作成され、そのなかにRailsアプリを動かすために必要な様々なディレクトリやファイルが作成されます。一通りディレクトリやファイルの作成が終わり、再度ターミナルからコマンド入力できる状態になったら、`cd`コマンドを使ってアプリのディレクトリに移動しましょう。

```
cd hello_world_sample
```

これでアプリのディレクトリに移動できました。確認のため、`ls`コマンドを実行してみてください。

```
ls
```

実行結果

```
Gemfile      README.md    app          config       db           log          public       test         vendor
Gemfile.lock Rakefile     bin          config.ru    lib          package.json storage      tmp
```

ディレクトリやファイルが確認できたら、`hello_world_sample`ディレクトリをテキストエディタ（Visual Studio CodeやAtomなど）にドラッグ&ドロップし、アプリに関連するディレクトリやファイルが全て編集できる状態にしておきましょう。

今回、自動的に作成されたディレクトリやファイルを今の時点で全て把握する必要はありませんが、以下のものだけしっかりと役割を理解しておいてください。

|ディレクトリ|役割|
|---|---|
|app|モデル、ビュー、コントローラを管理|
|config|ルーティング、データベースなどの設定ファイルの管理|
|db|マイグレーションファイル、シードデータファイルの管理|

`Ruby on Rails`はディレクトリ階層が厳しく管理されているので、その階層構造をしっかりと守ることが大切です。そのため、どこに何があるかはまず優先的に覚えておくといいでしょう。

## データベースを作成する
データベースとは、Webアプリケーションの中で使用されるデータを整理整頓し、管理するためのものです。立ち上げたアプリに関連するデータベースを作成する場合は、以下のコマンドを実行するだけでOKです。

```
bundle exec rake db:create
```

実行結果（開発環境とテスト環境のデータベースが作成されます）

```
Created database 'db/development.sqlite3'
Created database 'db/test.sqlite3'
```

また、このコマンドは一度実行した後は再度実行する必要はありません。

すでにデータベースが作成されたアプリでは、データベースを使う準備ができているので、最初の一回だけ実行するようにしましょう。再度実行すると、「すでにデータベースは存在しています」ということで以下のようなエラーが表示されます。

```
Database 'db/development.sqlite3' already exists
Database 'db/test.sqlite3' already exists
```

それでは、データベースの作成が完了したら、Webサーバを起動しましょう。RailsアプリはWebアプリケーションなので、Webサーバーが起動していないと動作を確認することができません。

そのため、以下のコマンドを実行してWebサーバーを立ち上げましょう。ちなみに、Railsに付属しているWebサーバーは`WEBrick`と呼ばれています。

```
rails s
```

サーバーが起動できたら、初期画面へアクセスしてみましょう。以下のリンクから、初期画面へアクセスすることができます。それが確認できたら、アプリの立ち上げは成功です。これから何度もやる流れなので、ぜひ今回の手順を繰り返し確認してみてください。

[http://localhost:3000/](http://localhost:3000/)

## MVCモデルの理解
`MVCモデル`は、Railsアプリを開発する上でとても重要な概念で、MVCというアルファベットのそれぞれの意味は以下の表の通りです。ちょっと難しい部分なので、今はさらっと読んでおくだけで大丈夫です。

|頭文字|読み|役割|
|---|---|---|
|M|モデル|データベースとのデータのやり取り、複雑なロジックを記述、バリデーションの設定|
|V|ビュー|ユーザーの目に触れる部分|
|C|コントローラ|処理の振り分け|

MVCモデルでは、以上のようにプログラムが明確に役割分担されています。それによって、コードの管理、運用保守が簡単に行えるようにしています。

例えば、プログラミングのわからないデザイナーでもビューの部分だけなら編集ができるようになったり、処理の振り分けを変えたいならコントローラの部分の記述だけを変えたりと、どこのコードを編集すればいいかを明確にできたり、一部のコードを変更しても他の部分のコードの変更が最小限に抑えられるようになるのです。


# Railsアプリ開発の流れ
Railsアプリを開発する時は、以下の流れで行います。こちらもアプリ開発をする上では基本となるとても重要な流れなので、ぜひしっかりと頭に入れておいてください。

1. ルートの定義
2. コントローラの作成とアクションの定義
3. ビューの作成

とにかく、初心者のうちは「ルート・コントローラ・ビュー」の順番で基本的に開発を行うということを頭に入れておいてください。これがRailsアプリ開発の重要な手順となります。

## ルートの定義
では早速、手順1のルートの作成から始めていきましょう。まずはファイルのある場所をしっかりと覚えてください。ルートを設定するためのファイルは`config`ディレクトリの中にあります。

```
config/routes.rb
```

ファイルが確認できたら、その中にルートを設定しましょう。ルートを設定する際は、`アクセスされるURL`、`そのURLに対応するコントローラ`、`指定したコントローラのアクション`を記述します。以下は、ルートを設定するときの一つの例です。

```ruby
# 左側がURL　右側がコントローラの名前とアクション
get '/homes', to: 'homes#index'
```

上の例は以下のような構成になっています。

```
HTTPメソッド 'ユーザーが指定するURL', to: 'コントローラー名#アクション名'
```

これが基本的な書き方なので、ぜひ頭に入れておいてください。また、ここで出てきた`HTTPメソッド`には以下のような種類があります。

|HTTPメソッド|役割|
|---|---|
|POST|データの登録|
|GET|データの一覧表示|
|PATCH/PUT|データの更新|
|DELETE|データの削除|

これらを使い分けて、今後、「データの一覧表示・登録・更新・削除」というWebアプリケーションの基本的な機能を実装していくので頭の片隅に置いといてください。ちなみに、このような一連の処理を`CRUD処理`といいます。こちらを先ほどのHTTPメソッドと合わせてまとめると、以下のようになります。

|HTTPメソッド|CRUDの種類|役割|
|---|---|---|---|
|POST|Create|登録|
|GET|Read|表示|
|PATCH/PUT|Update|更新|
|DELETE|Delete|削除|

# コントローラの作成
先ほど、ルートの設定の部分で以下のように記述しました。

```ruby
# get '/homes'がHTTPメソッドとURL、to: 'homes#index'がコントローラの名前とアクション
get '/homes', to: 'homes#index'
```

このとき「ユーザーが`http://localhost:3000/homes`というように`/homes`を指定してアクセスすると、`homes`コントローラの`index`アクションに処理が振り分けられる」ということになります。そのため、次は`homes`コントローラを作成し、その中に`index`アクションを追加しましょう。

まずは、コントローラを作成するために以下のコマンドをターミナルで実行します。（`rails s`でサーバーを立ち上げている場合は`command + c`でサーバーを停止してから行ってください）

```
rails g controller homes
```

実行結果（複数のディレクトリやファイルが作成される）

```
Running via Spring preloader in process 1462
      create  app/controllers/homes_controller.rb
      invoke  erb
      create    app/views/homes
      invoke  test_unit
      create    test/controllers/homes_controller_test.rb
      invoke  helper
      create    app/helpers/homes_helper.rb
      invoke    test_unit
      invoke  assets
      invoke    coffee
      create      app/assets/javascripts/homes.coffee
      invoke    scss
      create      app/assets/stylesheets/homes.scss
```

`rails g controller homes`のコードの`homes`の部分には、自分が作成したいコントローラ名を入力することで、自分が作りたい任意の名前でコントローラを作成することができます。例えば、`users`コントローラを作成したいときは以下のコマンドで作成できます。

```
rails g controller users
```

また、Railsのルールとして、コントローラ名(`homes`や`users`の部分)は基本的に複数形にすることが推奨されています。

それでは次に、コントローラのアクションを定義していきましょう。先ほど`rails g controller homes`を実行しましたが、そうすると以下の場所に`homes_controller.rb`というファイルができています。

```
app/controller/homes_controller.rb
```

コントローラが作成できたら、次にアクションを追加します。ルートの設定の部分で`homes`コントローラに対して`index`アクションを指定したので、ファイルの中に`index`アクションを定義しましょう。こちらは、Rubyのメソッドを定義するときと同じ記述で定義できます。

```rb
class HomesController < ApplicationController
  # indexアクションを定義
  def index

  end
end
```

上の記述がアクションの基本的な設定方法になります。基本的な構成として`def`と`end`で囲み、ルートの指定に対応するアクション名を定義してあげます。

```
def アクション名

end
```

# ビューの作成
コントローラのアクションが定義できたら、そのアクションに対応するビューを作成しましょう。ビューファイルは以下の場所で管理されています。

```
app/views
```

その中に、デフォルトで`layouts`というディレクトリが存在します。また、そのほかにも`homes`というディレクトリが存在するかと思います。このディレクトリは、先ほど`rails g controller homes`というコマンドを実行した時に作成されたものです。つまり、コントローラを作成すると、それに対応するビューのディレクトリも一緒に作成されるということです。

ビューファイルは、コントローラのアクションに対応する名前にします。今回のサンプルであれば、`homes`コントローラの`index`アクションに対応するビューファイルを作成するので、`app/views/homes`の中に`index.html.erb`というファイルを作成します。

コントローラに関してはターミナルからコマンドで作成しましたが、ビューは`テキストエディタから直接`ファイルを作成しましょう。テキストエディタ上にて`homes`ディレクトリを右クリック（Macだと2本指でタップ）し、`New File(テキストエディタによって表示が異なる)`を選択してファイルを作成し、`名前をつけて保存`で`index.html.erb`と入力して保存をしましょう。

```
index.html.erb
```

上の記述の中で、`.html.erb`の部分は拡張子となります。これはRails特有の拡張子で、`erb`は`embedded ruby`という意味になるます。`embedded`という単語が「埋め込まれた」という意味なので、「HTMLの中にrubyを埋め込むことができる」ということになります。

では、さっそく作成したビューファイルにHTMLの`h1`タグで`Hello World`を表示するコードを書いてみましょう。

```
<h1>Hello World!!</h1>
```

# URLを指定して画面の表示
HTMLを書いたら、ターミナルからサーバーを立ち上げ、実際に画面に`Hello World!!`が表示されるか確かめます。サーバーを立ち上げるには、以下のコマンドを実行します。

```
rails s
```

コマンドを実行したら、ルーティングで設定した`/users`にブラウザからアクセスしましょう。その際、デフォルトのURLである`http://localhost:3000`に`/homes`を加えてリクエストすることでルーティングで定義した`get '/homes', to: 'homes#index'`が指定され、`homes`コントローラの`index`アクションを介して`/views/homes/index.html.erb`にアクセスできます。その後、`/views/homes/index.html.erb`に記述した`Hello World!!`がブラウザに表示されれば成功です。

[http://localhost:3000/homes](http://localhost:3000/homes)

# コントローラからのデータの受け渡し
先ほど、`homes`コントローラの`index`アクションを定義しましたが、現在はそのアクションを全く活用していません。しかし、実際にアプリを作成するときには、コントローラを介して「モデルから取得したデータをビューに渡す」ということをよくやります。

そのため、まずは「コントローラからビューにデータを渡す」ということをやってみましょう。まずは、`homes`コントローラの`index`アクションにてインスタンス変数を定義します。その中に、`Hello World!!`という文字列を格納してみましょう。


```rb
class HomesController < ApplicationController
  def index
    @greet = ""Hello World!!""
  end
end
```

こちらの記述が終わったら、一旦、`/views/homes/index.html.erb`の記述を全て削除し、以下のように記述してみてください。

```
<%= @greet %>
```

ビューの記述が終わったら、ブラウザから`http://localhost:3000/homes`にアクセスしてみましょう。その後、画面に「Hello World!!」と表示されれば「コントローラからビューへのデータの受け渡し」が成功しています。

# モデルからコントローラへのデータの受け渡し
次に、「モデルからコントローラへのデータの受け渡し」をしてみましょう。Railsアプリの開発においては、MVCのアーキテクチャを理解することが大切だとお伝えしたのですが、今の状態ではM（モデル）に一切触れておらず、いまいちモデルの存在意義が理解しにくいかと思います。そのため、新しくモデルを定義し、それをコントローラで使用することによってモデルの基本的な活用方法について学んでいきましょう。

まずは、`/app/models`に`user.rb`モデルを作成します。その中に、`User`クラスを定義し、個人情報に関するパラメータや自己紹介を行うメソッドを定義してみましょう。こちらのコードに関しては、ご自身の情報を自由に入れていただいて結構です。せっかくなので、ご自身で色々考えて設定したいパラメータやメソッドを自由に定義してみてください。

```rb
class User
  def initialize
    @first_name = ""Yoshito""
    @last_name = ""Kamizato""
    @birthday = ""1987/4/10""
    @age = 32
    @birthplace = ""Okinawa/Nago""
    @hobby = ""Video Game""
  end

  def introduce
    <<~EOS

    私の名前は#{@first_name + @last_name}です。
    誕生日は#{@birthday}で、年齢は#{@age}歳。
    出身地は#{@birthplace}で、趣味は#{@hobby}です。

    EOS
  end
end
```

`User`モデルの定義が終わったら、そちらを`homes`コントローラから`User`モデルをインスタンス化し、`introduce`メソッドを実行してその結果を`@my_introduce`に格納してみましょう。

```rb
class HomesController < ApplicationController
  def index
    @greet = ""Hello World!!""

    # Userモデルをインスタンス化
    user = User.new
    # introduceメソッドを実行
    @my_introduce = user.introduce
  end
end
```

これで、`Homes`コントローラから`User`モデルのメソッドを使用し、データを受け取ってビューに渡す準備が整いました。それではさっそく、`@my_introduce`に格納したデータをビューで表示してみましょう。`/views/homes/index.html.erb`のを以下のように編集してみてください。

```
<%= @greet %>
<!-- @my_introduceのデータを表示 -->
<%= @my_introduce %>
```

そうすると、以下のようにデータがうまく表示されるかと思います。

```
Hello World!! 私の名前はYoshitoKamizatoです。 誕生日は1987/4/10で、年齢は32歳。 出身地はOkinawa/Nagoで、趣味はVideo Gameです。
```

しかし、ここで予期せぬ結果になってしまいます。それは、`User`モデルで定義した`introduce`メソッドのヒアドキュメントの改行が反映されていないことです。このままではとてもみづらいので、改善していきましょう。今回のように期待した結果と異なるとき、現場では自分で色々ググってみて情報を集めながら解決していくので、その練習として「rails　改行　反映」などのキーワードを入れて検索してみてください。そうすると、ヒントがかかれてある記事がヒットするかと思います。

今回の場合、ヒアドキュメントの改行を反映させるためには以下のようにビューの記述を変更します。

```
<%= @greet %>
<!-- simple_formatで@my_introduceを囲む -->
<%= simple_format(@my_introduce) %>
```

表示結果

```
Hello World!!

私の名前はYoshitoKamizatoです。
誕生日は1987/4/10で、年齢は32歳。
出身地はOkinawa/Nagoで、趣味はVideo Gameです。
```

無事に改行が反映されましたね。`simple_format`はヘルパーメソッドと呼ばれるものの１つで、`\n`や`\r\n`などの改行コードを`<br />`という改行をさせるためのHTMLタグに変換してくれます。その結果、ヒアドキュメントの改行がきちんと反映された状態になります。

このようにRailsでは、「ルーティングでコントローラのアクションを指定し、コントローラがモデルやビューに処理を振り分け、ユーザが必要としているデータを提供する」ということを行います。

その中でも、Rubyの基礎学習が活きるのはモデルでロジックを書く部分です。ここで、今まで学んできた基礎知識が一気に役立つようになってきます。今後転職活動を進める上でも「モデルにロジックを書いているかどうか」はシビアに確認される部分になりますので、オリジナルのアプリを作成する際にも、ぜひそれを意識して柔軟にご自身が実現したい処理をモデルに定義してみてください。色々遊びながら、ロジックを書くことにも慣れておくといいですね。

# 最後に
これで今回作成するアプリが完成したわけですが、最後にもう一つ、Railsを理解する上で重要な部分をご説明します。

実は、Railsでは`views/layouts`の中に`application.html.erb`というファイルがあり、それがWeb上に画面を表示する際のテンプレートとなっています。`application.html.erb`は、アプリを作成した直後は以下のような状態になっています。

```
<!DOCTYPE html>
<html>
<head>
  <title>ControllerTest</title>
  <%= stylesheet_link_tag    'application', media: 'all', 'data-turbolinks-track' => true %>
  <%= javascript_include_tag 'application', 'data-turbolinks-track' => true %>
  <%= csrf_meta_tags %>
</head>
<body>

<%= yield %>

</body>
</html>
```

この`application.html.erb`のコードの中で注目していただきたいのが、`<%= yield %>`の部分です。実は、先ほど`Hello World!!`を表示した際、この`<%= yield %>`の部分が`/views/homes/index.html.erb`の内容と置き換わって表示されていたのです。つまり、イメージとしては以下のようになります。

```
<!DOCTYPE html>
<html>
<head>
  <title>ControllerTest</title>
  <%= stylesheet_link_tag    'application', media: 'all', 'data-turbolinks-track' => true %>
  <%= javascript_include_tag 'application', 'data-turbolinks-track' => true %>
  <%= csrf_meta_tags %>
</head>
<body>

<!-- yieldがindex.html.erbの内容と置き換わる -->
<%= @greet %>
<%= simple_format(@my_introduce) %>

</body>
</html>
```

# まとめ
今回は、「Hello World!!」の表示を通して以下の流れでユーザーのリクエストが処理されルことを学びました。

1. ユーザーがリクエストを送信する（ブラウザからURLにアクセスする）
2. ルートによりURLに対応するコントローラのアクションに処理が振り分けられる
3. コントローラのアクション内で必要なデータをモデルとやりとりする
4. コントローラのアクションに対応するビューが表示される
 - ただし対応するビューが直接表示されるのではなく`layout`の`yield`がユーザーのリクエストに対応したビューと置き換わる

最初は混乱するかも知れませんが、ルート・コントローラ・モデル・ビューの実装を繰り返したり、サンプルコードをもとに自分なりにカスタマイズしてコードを書いていくうちに理解できるようになっていきます。

試しに、`index.html.erb`とは別に、`new.html.erb`を作成し、そのビューファイルが表示されるようにルート・コントローラ・ビューを編集して見ましょう。それに挑戦してみると、より理解が深まるかと思います。

今回はこれで以上です、お疲れ様でした！"
rails,Ruby on Rails アプリのデプロイ,"こちらでは、Railsで作成したWebアプリをHerokuにデプロイする手順をご説明いたします。

# Herokuに登録
まずは、Herokuにアカウントを作りましょう。

[Herokuアカウント作成](https://dashboard.heroku.com/account/billing)

# Heroku CLI のインストール
herokuコマンドを使えるようにするために、Heroku CLIをインストールします。

```
brew install heroku/brew/heroku
```

# アプリを作成

「Hello World」が表示できるアプリを作成しましょう。やり方がわからない場合は、Railsの基本をもう一度復習してみてください。

# デプロイ
Gemfileの SQLite の記述を以下のように変更します。

```
gem 'sqlite3', '~> 1.3.6', group: :development
gem 'pg', group: :production
```

gemをインストールします。

```
bundle install
```

`config/database.yml`を書き換えます。

```
production:
  <<: *default
  adapter: postgresql
  encoding: unicode
  pool: 5
```

以下のコマンドでherokuにデプロイの対象となるアプリを作成しましょう。

```
heroku create
```

Gitにてバージョン管理を行い、コミットまで完了させます。

```
git add .
```

```
git commit -m ""commit message""
```

gitを使用してherokuにアプリをプッシュします。

```
git push heroku master
```

heroku場でマイグレーションを実行し、データベースを作成します。

```
heroku run rake db:migrate
```

アプリを開きます。

```
heroku open
```

# デプロイ後にアプリを変更した場合
以下の手順でHerokuの更新を行ってください。

```
git add .
```

```
git commit -m ""commit message""
```

```
git push heroku master
```"
rails,CRUD処理の実装,"REST（Representational State Transfer）とは「ネットワーク上に置かれたリソース（データ）に対して表示、作成、更新、削除などの操作を行う」というアプリケーション作成における考え方です。

こちらは、Ruby on RailsでデータのCRUD処理（新規登録、一覧表示、更新、削除）を実装するにあたり、最初のうちから理解しておいた方がいいです。
ただ、一度に理解するのは難しいので、折をみて何度も繰り返し復習してみてください。

RESTは、Ruby on Railsアプリケーションを作成する上では重要な概念です。
この概念によって、効率よくデータベース上のデータを扱うことができます。

## RESTを意識したアプリケーションを作成するには
Ruby on RailsにおけるREST機能の中心を担うのがルーティングです。
Railsには、RESTに基づいたやり方でウェブアプリケーションを作成する機能があり、それにのっとって作成されたアプリを「RESTフル」といいます。

RESTの機能を利用すれば、Ruby on Railsの原則である「Don't Repeat Yourself（同じことを二度書かない）」や、「設定より規約（自由さよりもルール）」という考えを忠実に守ることができ、アプリケーションの開発や保守がより簡単になります。

Railsにおける「リソース」とは、コントローラが扱う対象となるデータのことです。
このリソースに対する、RESTフルなルーティングは以下の通りになります。

|HTTPメソッド|パス|コントローラのアクション|
|---|---|---|
|GET|/users|index|
|GET|/users/new|new|
|POST|/users|create|
|GET|/users/:id|show|
|GET|/users/:id/edit|edit|
|PATCH|/users/:id|update|
|DELETE|/users/:id|destroy|

上記の表において、`:id`の部分には任意の数字が入ります。
今はまだ用途がわからなくてもいいので、`:id`は整数を格納する変数のようなものだと理解しておきましょう。

この`:id`という記述によって、特定のデータを指定してデータの更新や削除を行うことができます。

# アプリの立ち上げ
今回、アプリを立ち上げる際は以下のコマンドを実行してください。

```
rails new crud_sample
```

## リソースを扱うコントローラ
コントローラでは、リソースベースのルーティングに従い決まった名前のアクションを7つ定義します。
このアクションに関しては、名前ごとに役割が決められているため、そのルールにしたがって実装すれば開発効率を向上させることができます。

以下の表には、RESTフルを実現させるために必要なアクション名とその役割をまとめておきます。

|アクション名|役割|対応するルーティング|
|---|---|---|
|index|リソースの一覧表示（テーブルのレコードを一覧表示）|/users|
|new|リソースを追加するためのフォームを表示する（新規作成画面を表示する）|/users/new|
|create|リソースを作成する（テーブルにレコードを追加する）|/users|
|show|リソースの詳細を表示する（レコードの詳細を表示する）|/users/:id|
|edit|リソースの更新画面を表示する（既存のレコードのカラムを更新するための画面）|/users/:id/edit|
|update|リソースを更新する（既存のレコードのカラムを更新する）|/users/:id|
|destroy|リソースを削除する（テーブルからレコードを削除する）|/users/:id|

コントローラにアクションを追加するときは、基本的に上の表にあるアクションを追加していきます。
実際にコードを書く際は、それぞれのアクションの役割をきちんと意識して使い分けられるようにしましょう。

ではさっそく、これからCRUD処理（新規登録、一覧表示、更新、削除）の実装をしていきましょう。
これが出来れば、晴れて初心者は卒業です。
何度も何度も繰り返して、体で覚えていきましょう。

# 新規投稿機能の実装
新規投稿機能を実装するためには、まず最初にデータベースが必要になります。
なので、以下のコマンドを実行してデータベースを作成しましょう。

```
bundle exec rake db:create
```

データベースが作成できたら、次にルーティングを設定します。
以下のコードを`config`ディレクトリ配下の`routes.rb`に記述しましょう。

```ruby
Rails.application.routes.draw do
  # 以下のルーティングを定義
  get '/users/new', to: 'users#new'
end
```

次にコントローラを作成します。
今回はユーザーのデータを扱うアプリを作成するので、`users`というコントローラを作成しましょう。
ターミナルから以下のコマンドを実行してください。

```
rails g controller users
```

無事に`users`コントローラが作成できたら、`app/controllers`の中にある`users_controller`を編集しましょう。

次は`new`アクションを定義します。
`users`コントローラに以下のコードを記述しましょう。

```ruby
class UsersController < ApplicationController
  # 以下のアクションを追加
  def new
    @user = User.new
  end
end
```

`users`コントローラに`new`アクションが作成できたら、`views/users`ディレクトリに`new.html.erb`を作成し、以下のコードを記述しましょう。
こちらが、投稿画面のフォームになります。

```
<%= form_for @user, url: ""/users"" , html: { method: :post } do |f| %>
  <p>投稿する</p>
  <p>お名前：<%= f.text_field :name %></p>
  <p>年齢：<%= f.text_field :age %></p>
  <%= f.submit %>
<% end %>
```

このフォームでは、`form_for`というヘルパーメソッドを使用しています。
Ruby on Railsには、基本的なフォームとして以下の2つがよく利用されています。

1. form_for
2. form_tag

この2つのフォームの使い分けは以下の通りです。

|フォーム名|用途|
|---|---|
|form_for|モデルに紐づいたフォームを作るときに使用する|
|form_tag|モデルに紐づかないフォームを作るときに使用する|

現場では、`form_for`の方が圧倒的に使用頻度が高いです。
実際、CRUD処理を実装するときは確実に`form_for`を利用すると考えてもいいくらい。

なぜ、モデルに紐づいたときに`form_for`を用いるのかというと、記述が圧倒的に楽になるからです。
今回はわかりやすいように、URLの部分を以下のように記載しました。

```
<%= form_for @user, url: ""/users"" , html: { method: :post } do |f| %>
```

しかし、実際は以下のように記述することもできるのです。

```
<%= form_for @user do |f| %>
```

`form_for`は紐づけられたモデルオブジェクト（今回なら`@user`）がすでにテーブルに存在しているのかどうかを判定してくれます。

もし、テーブルに同一データが存在してなければ`create`アクションに、存在していれば`update`アクションに、それぞれ自動的にルーティングを指定してくれるわけです。

以上の理由から、投稿フォームを作るなら`form_for`を利用して作成した方がいいです。
それに慣れれば、`form_tag`は簡単に扱えるようになります。

では、投稿画面が作成できたら、実際にデータを登録するテーブルとそれに関連するモデルを作成しましょう。
まずは以下のコマンドを実行し、`user`モデルを作成しましょう。

```
rails g model user
```

`rails g model`コマンドを実行すると、同時にマイグレーションファイルも作成されます。
このファイルは、データベースにどのような構造のテーブルを作成するかを指定することができます。
今回は、ユーザーの名前と年齢を登録できるテーブルを作成したいので、`name`と`age`のカラムが作成されるよう以下のコードを書きましょう。

```ruby
class CreateUsers < ActiveRecord::Migration[5.2]
  def change
    create_table :users do |t|
      t.string        :name
      t.integer       :age
      t.timestamps
    end
  end
end
```

ちなみに、マイグレーションファイルで指定できる型には以下のようなものがあります。
必要に応じて、指定する型を変えてください。

|データ方|説明|
|---|---|
|string|文字列|
|text|長い文字列|
|integer|整数|
|float|浮動小数|
|decimal|精度の高い小数|
|datetime|日時|
|timestamp|より細かい日時|
|time|時間|
|date|日付|
|binary|バイナリデータ|
|boolean|Boolean型|

マイグレーションファイルは中身を変更するだけではダメです。
以下のコマンドを実行し、マイグレーションファイルの内容をデータベースに反映させましょう。

```
bundle exec rake db:migrate
```

そうすると、アプリに紐づいたデータベースの中に、`users`テーブルが作成されます。

テーブルが作成できたら、次にデータベースにデータを登録するためのルーティングやコントローラの処理を実装していきます。

まずは、ルーティングから設定しましょう。

`config`  の中にある、 `routes.rb`を編集します。
新たなルーティングとして、`post`メソッドで`users`コントローラの`create`アクションを指定しましょう。

```ruby
Rails.application.routes.draw do
  get '/users/new', to: 'users#new'
  # 以下のルーティングを追加
  post '/users', to: 'users#create'
end
```

ルーティングが指定できたら、次にコントローラのアクションでデータを登録するための処理を書いていきます。
`app/controllers`の中にある `users_controller.rb` を開いてください。

## Strong Parameter
Railsでは、データベースに予期せぬ値が登録されないように、登録する値を制限できる機能があります。
それにより、「数字を登録するはずのところに文字列が登録される」といった不測の自体を防いでくれます。
そして、その機能を実現するのが`Strong Parameter`です。ではさっそく、その機能を実装していきましょう。

まずは、`users`コントローラに`create`アクションを追加します。

```ruby
class UsersController < ApplicationController

  def new
    @user = User.new
  end

  # 以下のアクションを追加
  def create
    # Strong Parameter の記述
    User.create(user_params)
  end

end
```

`create`アクションが追加できたら、同じ`users`コントローラ内に以下のコードを追記します。
こちらが、データベースに登録するデータを制限するための`Strong Parameter`の記述になります。

```ruby
class UsersController < ApplicationController

  def new
    @user = User.new
  end

  def create
    User.create(user_params)
  end

  # 以下のメソッドを追加
  private
  def user_params
    params.require(:user).permit(:name, :age)
  end
end
```

この記述により、 `user` のパラメータに紐づいた `name` や `age` しかデータベースに登録できないようになります。

なぜ `user` に紐づいた `name` や `age` がパラメータとしてコントローラで取得できるのかというと、 `form_for` の部分で `User` モデルに対するフォームを作成しているからです。

そのため、 `User` モデルを格納した `@user` を用いて  `form_for @user` と記述すると、送信ボタンを押したときには `user` に紐づいたパラメータが送信されます。



`create`アクションが追加できたら、`views/users`ディレクトリに`create.html.erb`を追加します。
追加が終わったら、`create.html.erb`に以下のコードを記述しましょう。

```
<h1>登録完了</h1>
<%= link_to ""一覧画面へ"", ""/users"" %>
```

ここまできたら、データベースにデータが登録できたか確認してみてください。
自分が投稿したデータがテーブルに保存されていれば、投稿機能の実装は成功です。

まずは、サーバーを立ち上げましょう。

```
rails s
```

サーバーが立ち上げられたら、以下のURLにアクセスしてください。

[http://localhost:3000/users/new](http://localhost:3000/users/new)

# 一覧表示機能の実装
新規投稿機能が実装できたら、次は投稿を一覧表示するための機能を作成します。
といっても、実装は簡単なのでサクッと終わらせちゃいましょう！

まずは、一覧表示画面へのルートを作成します。

```ruby
Rails.application.routes.draw do
  # 以下のルーティングを追加
  get '/users', to: 'users#index'
  get '/users/new', to: 'users#new'
  post '/users', to: 'users#create'
end
```

ルートが作成できたら、投稿したデータをデータベースから取り出す処理を書きます。
`users`コントローラに`index`アクションを定義し、以下のコードを書きましょう。

```ruby
class UsersController < ApplicationController
  # 以下のアクションを追加
  def index
    @users = User.all
  end

  def new
    @user = User.new
  end

  def create
    User.create(user_params)
  end

  private
  def user_params
    params.require(:user).permit(:name, :age)
  end
end
```

`views/users`ディレクトリに`index.html.erb`を作成し、そこに以下のコードを記述しましょう。
これで、ユーザーデータが一覧表示できるようになります。

```
<%= link_to ""投稿画面へ"", ""/users/new"" %>
<% @users.each do |user| %>
  <p>
    <%= user.name %>
    <%= user.age %>
  </p>
<% end %>
```

ここまでできたら、一度サーバーを立ち上げRailsアプリの動作を確認してみましょう。
ユーザーのデータが一覧表示されていれば大丈夫です。
以下のURLでアクセスしてみてください。

[http://localhost:3000/users](http://localhost:3000/users)

# 削除機能の実装
データが一覧表示できたら、つぎにデータの削除機能を実装しましょう。
まずは、削除ボタンを作成します。

```
<% @users.each do |user| %>
  <p>
    <%= user.name %>
    <%= user.age %>
    <%= link_to '削除', ""/users/#{user.id}"", method: :delete, data: {confirm: ""削除しますか?""}  %>
  </p>
<% end %>
```

次に削除ボタンを押した時のルートを決めます。
以下のコードを`config/routes.rb`に追記しましょう。
すでに設定しているルートの下に書いて大丈夫です。

```ruby
Rails.application.routes.draw do
  get '/users', to: 'users#index'
  get '/users/new', to: 'users#new'
  post '/users', to: 'users#create'
  # 以下のルーティグを追記
  delete '/users/:id', to: 'users#destroy'
end
```

ここで`delete`などのメソッドの使い分けを確認！
ただページを遷移するだけなら`get`を使用しますが、それ以外は行いたい処理に合わせてHTTPメソッドを変更する必要があります。
ここで一通り、どんなHTTPメソッドがあるか確認しておきましょう。

|HTTPメソッド|用途|パス|コントローラ#アクション|
|---|---|---|---|
|GET|一覧表示|/users|users#index|
|GET|データ登録画面|/users/new|users#new|
|POST|データ登録|/users|users#create|
|DELETE|データ削除|/users/:id|users#destroy|
|PATCH/PUT|データ更新|/users/:id|users#update|

ルートが設定できたら、次は該当するユーザーのデータを削除する処理をコントローラに書きましょう。
その際使用するのは`destroy`というメソッドです。
`users`コントローラのアクションは`delete`ですが、実際に使用するメソッドは`destroy`であることに注意しましょう。

```ruby
class UsersController < ApplicationController

  def index
    @users = User.all
  end

  def new
    @user = User.new
  end

  def create
    User.create(user_params)
  end

  # 以下のアクションを追加
  def destroy
    user = User.find(params[:id])
    user.delete
  end

  private
  def user_params
    params.require(:user).permit(:name, :age)
  end
end
```

上のコードに関して、 `destroy` アクションでインスタンス変数（ `@user` など@マークのついた変数）を使用しない理由は、ビューにデータを受け渡す必要はないからです。

`delete` メソッドでは、ユーザーの情報を消すだけです。
なので、ビューにデータを受け渡す必要はなく、そのためインスタンス変数を使用せず、 `user` に対して `delete` メソッドを実行しています。。

アクションが追加できたら、 `views/users` ディレクトリにある `destroy.html.erb` に以下のコードを追加します。

```
<h1>削除完了</h1>
<%= link_to ""一覧画面へ"", ""/users"" %>
```

以上で削除機能の実装は完了です。
データが削除できるか確認したら、次は編集機能の実装に移りましょう。

# 編集機能を実装
編集機能を実装する際も、基本的には `delete` と感覚は同じです。
該当するユーザーデータの`id`パラメータを飛ばし、それをコントローラで受け取って`update`メソッドを実行するだけ！
それでは、学んでいきましょう。

編集画面へ遷移するためのボタンを一覧表示画面に作成します。
 `views/users` ディレクトリにある `index.html.erb` に以下のコードを追記しましょう。

```
<%= link_to ""投稿画面へ"", ""/users/new"" %>
<% @users.each do |user| %>
  <p>
    <%= user.name %><%= user.age %>
    <%= link_to '削除', ""/users/#{user.id}"", method: :delete, data: {confirm: ""削除しますか?""}  %>
    <%= link_to '編集', ""/users/#{user.id}/edit"", method: :get %>
  </p>
<% end %>
```

リンクが作成できたら、編集画面へ遷移するためのルートを設定します。

```ruby
Rails.application.routes.draw do
  get '/users', to: 'users#index'
  get '/users/new', to: 'users#new'
  post '/users', to: 'users#create'

  # 以下のルーティングを追加
  get '/users/:id/edit', to: 'users#edit'

  delete '/users/:id', to: 'users#destroy'
end
```

ルーティングが設定できたら、 `users` コントローラに `edit` アクションを定義し、編集対象となるユーザーのデータを取得するための処理を書きましょう。

```ruby
class UsersController < ApplicationController

  def index
    @users = User.all
  end

  def new
    @user = User.new
  end

  def create
    User.create(user_params)
  end

  # 以下のアクションを追加
  def edit
    @user = User.find(params[:id])
  end

  def destroy
    user = User.find(params[:id])
    user.delete
  end

  private
  def user_params
    params.require(:user).permit(:name, :age)
  end
end
```

`edit` アクションが追加できたら、 `views/users` ディレクトリに `edit.html.erb` を作成し、以下のコードを記述しましょう。

```
<%= form_for @user, url: ""/users/#{@user.id}"", html: { method: :patch } do |f| %>
  <p>更新</p>
  <p><%= f.text_field :name %></p>
  <p><%= f.text_field :age %></p>
  <input type=""submit"" value=""送信"">
<% end %>
```

編集完了画面へのルーティング

```ruby
Rails.application.routes.draw do
  get '/users', to: 'users#index'
  get '/users/new', to: 'users#new'
  post '/users', to: 'users#create'
  get '/users/:id/edit', to: 'users#edit'

  # 以下のルーティングを追加
  patch '/users/:id', to: 'users#update'

  delete '/users/:id', to: 'users#destroy'
end
```

ルーティングが設定できたら、 `users` コントローラにデータを更新するための `update` アクションを追加

```ruby
class UsersController < ApplicationController

  def index
    @users = User.all
  end

  def new
    @user = User.new
  end

  def create
    User.create(user_params)
  end

  def edit
    @user = User.find(params[:id])
  end

  # 以下のアクションを追加
  def update
    user = User.find(params[:id])
    user.update(user_params)
  end

  def destroy
    user = User.find(params[:id])
    user.delete
  end

  private
  def user_params
    params.require(:user).permit(:name, :age)
  end
end
```

アクションが追加できたら `view/users` ディレクトリに `update.html.erb` を作成し、以下のコードを記述しましょう。

```
<h1>更新完了</h1>
<%= link_to ""一覧画面へ"", ""/users"" %>
```

これで編集機能の実装が完了しました。ユーザーのデータがきちんと更新できるか確認してみましょう。更新が確認できたらCRUD処理の実装は一通り終了です。
お疲れ様でした。

## おまけ
CRUD処理は実装できたのですが、コントローラの記述でもう少し改善できるところがあります。それが、 `create` `update` `destroy` の部分です。

これらのアクションに対応するビューは特に表示しなくても問題ないので、処理をした後すぐに一覧表示画面に遷移するようにしても問題ありません。

アクションの中で特定の処理をした後、他のアクションに処理を渡すためには `redirect_to` を使用します。以下のように、コントローラを編集してみましょう。

```ruby
class UsersController < ApplicationController

  def index
    @users = User.all
  end

  def new
    @user = User.new
  end

  def create
    User.create(user_params)
    # 以下のメソッドを追加
    redirect_to :action => ""index""
  end

  def edit
    @user = User.find(params[:id])
  end

  def update
    user = User.find(params[:id])
    user.update(user_params)
    # 以下のメソッドを追加
    redirect_to :action => ""index""
  end

  def destroy
    user = User.find(params[:id])
    user.delete
    # 以下のメソッドを追加
    redirect_to :action => ""index""
  end

  private
  def user_params
    params.require(:user).permit(:name, :age)
  end
end
```

以上のように編集することで、 `create` `update` `destroy` の処理を行った後に、すぐに `index` に処理が渡されるようになりました。

試しに、データを新規作成し、データを投稿した後すぐに一覧表示画面に遷移するか確かめてみてください。確認できたら、実装は完了です。


# まとめ
このCRUD処理に関しては、現場でプログラマーとして働くためのボーダーラインと言われています。ということは、この処理をしっかり実装できるようになるだけで、現場で働くための最低限のスキルが身についたということになります。

この流れはとても大切なので、何度も繰り返し実装してみてください。

また、RESTフルなアプリケーションとはなんなのかを改めて確認しておきましょう。

お疲れ様でした！

[ソースコードを確認する](https://github.com/yoshitokamizato/crud_sample2.git)"
php,1-1 PHPの基本,"### PHPとはどんな言語か
`PHP`とは動的にWebページを生成することができる`サーバーサイド`のスクリプト言語です。他のプログラミング言語と比較して仕様や文法が比較的わかりやすく、初学者でも習得しやすいと言われています。

また`MySQL`などのデータベースとの連携が容易なことなどから、`WordPress`（この講座では扱いません）を含めたWebアプリケーションの開発にもよく使われる有名なスクリプト言語でもあります。

`PHP`と同じサーバーサイドのスクリプト言語には`Ruby`、`Python`、`Java`などがあります。

### 言語バージョン
本教材は以下の条件で動作確認しております。

    PHP：version 7.3.11
    ブラウザ：Google Chrome

プログラミングでWebアプリケーションを開発していく上でよっぽどの理由がない限りはブラウザは`Google Chrome`を使いますので、`Google Chrome`をダウンロードしていない方はダウンロードしておいてください。

### 基本の書き方

PHPを使用した処理は以下のように書きます。

```php
<?php

//処理したい内容

?>
```

`<?php`と`?>`の間に処理したい内容を書いていきます。

`<? php>`のように?とphpの間に**半角スペース**を入れてしまうとエラーとなり処理が実行されないのでご注意ください。

### 「?>」の省略について
コードの結びの`?>`ですが、その後に`HTML`や`JavaScript`などの他の言語のコードがない時は以下のように文末の`?>`を省略することもできます。

（超余談ですが、PHPのフレームワークの中には`?>`を省略しなければならないものあります）

```php
<?php

//処理したい内容
```

ですが、ポピュラーな書き方としては結びに`?>`をつける方ですので、本講座のテキストではコードの終わりに`?>`を付けて進めてきます。

今は「へえ、なるほど」くらいで良いですが、`HTML`のタグの中に`PHP`のコードを書くこともあり、その場合は以下のように`<?php`と`?>`が必須となります。

```html

//HTMLのタグの中にPHPのコードを埋め込む時
<P><?php echo 'Hello World!'; ?></p>

```

また、初心者向けのPHPの書籍、とても有名なプログラミング教材である`Progate`などでも

```php
<?php

//処理したい内容

?>
```

のように終わりに`?>`をつけた書き方で紹介されていますので問題ないと思います。

これから少しずつ、`PHP`でのプログラムの書き方について勉強していきます。頑張りましょう！"
php,1-2 PHPでHello World!を表示させてみよう,"前回の講座ではPHPとはどんな言語なのか、`PHP`での基本的な書き方について学習しました。おさらいになりますが、`PHP`でのプログラムの書き方についてもう一度見てみましょう。

```php
<?php

//処理したい内容

?>
```

それでは本講座では`PHP`で`Hello World!`を表示させてみようと思います。

`PHP`ファイルを実行する方法は大きく2つあります。

- ターミナル上で実行
- Webサーバー上で実行（ブラウザで表示する）

### ターミナルで表示させる場合

まず、お好きなエディターを立ち上げてください。（オススメは`VSCode`です）

デスクトップに`gyakuten_php`ディレクトリを作成し、その中に`index.php`というファイルを作成し、以下のコードを書いてください。(`PHP`のファイルは拡張子が`.php`です)

ちなみディレクトリ名とファイル名は何でもOKです。

```php
<?php

echo ""Hello World!\n"";

?>
```

次に、ターミナルを立ち上げ、以下を順に実行し、`gyakuten_php`フォルダに移動します。

    cd ~/Desktop
    cd gyakuten_php

`cd`はL`inuxコマンド`であり、`PHP`ではありませんが使えるようにしておきましょう。

それではPHPファイルに書いたプログラムを実行していきます。

ターミナルでを以下の実行してください。

    php index.php

するとターミナルに以下の文字が表示されます。

    Hello World!

これで正常にPHPの処理が実行されました。それではコードの解説をしていきます。

```php
//echoは文字列や数字等を出力する命令
<?php 

echo ""Hello World!\n"";

?>
```
`echo`は文字列や数を出力するための命令です。PHPで出力するためには`echo`の他に`print`を使用することもできます。（文字を出力するためのメソッド（命令）は他にもあります）

`print`を使用する場合は以下のように記述します。

```php
<?php

//printは文字列や数字等を出力する命令
print(""Hello World!\n"");

?>
```

`print`を使用する場合は、出力したい文字列や数字にカッコをつける必要があります。

本教材では出力の命令には`echo`を用いることにします。(`print`でも問題ありません)

文字列を出力する場合はシングルクオーテーション「'」もしくはダブルクオーテーション「""」で囲みます。

処理の最後にはセミコロン「;」を必ず付けます。

`n\`は「改行」を表します。

`PHP`で文字列を改行させる方法は`n\`の他にもあります。

```php
<?php

//文字列を改行させる方法
print(""Hello World!\n"");
print(""Hello World!<br>"");
print(""Hello World"". PHP_EOL);

?>
```

試しに`n\`を付けずにターミナルからプログラムを実行してみてください。

    Hello World PC機種:gyakuten_php ユーザー名$ 

このように改行されずに表示されます。改行の方法自体はググればいくらでも出てきますので今の時点でしっかり覚える必要はありません。ターミナルで実行する場合は改行の処理を行わなければ出力が横繋がりになってしまう、ということだけ頭に入れておいてください。

以上が、PHPの処理をターミナルで実行する場合の手順です。

### Webサーバー上で実行（ブラウザで表示する）
先ほどはターミナルに表示する方法について解説しましたが、次はブラウザで`Hello World!`を表示してみましょう。

まずはパソコンで`PHP`を勉強するための動作環境を作ります。

#### Windowsの場合
Windowsの場合は**XAMPP**（ザンプ）というソフトウェアのパッケージをインストールし、PHPとMySQLでの開発環境を準備します。

こちらの[XAMPPのインストール方法](https://ferret-plus.com/8403)からお使いのPCにXAMPPをインストールしてください。

起動方法と使い方についても上記リンクに記載されていますが、XAMPPをインストールしたら、

    スタートメニュー/XAMPP/XAMPP Controll Panel

をクリックし起動します。

その後、「Apache」および「MySQL」と書かれた行の「Start」ボタンをクリックします。
「Apache」と「MySQL」と書かれたラベルが緑になればXAMPPの起動が完了です。
（StartボタンはStopに変わります）

次に処理を実行したいファイルを実行用フォルダに移動またはコピーします。

デスクトップに作成した`gyakuten_php`フォルダを

    /xampp/htdocs

フォルダに移動またはコピーします。

これでPHPファイルを実行する準備は整いましたので、ブラウザ（Google Chrome）を開きURL欄に以下の通り打ち込みます。

    http://localhost/gyakuten_php/index.php

すると以下のようにブラウザに表示されます。

    Hello World!

これでブラウザでPHPファイルの処理を表示することができました。
Windowsを使いの方は以降は同様の手順でファイルを実行してください。

#### Macの場合
Macをお使いの方は**MAMP**（マンプ）というソフトウェアのパッケージをインストールし、PHPとMySQLでの開発環境を準備します。

こちらの[MAMPのインストール方法](https://techacademy.jp/magazine/5102)からお使いのPCにMAMPをインストールしてください。

MAMPのアプリケーションのクリックしを起動させ、`Start Servers`と書かれた電源マークを押してください。そうすると緑に点灯し、右上に小さく書かれた<br>

    Apach Server
    MySQL Server

の右の丸も緑になります。これでMAMPの起動は完了です。

では、処理を実行したいファイルを実行用フォルダに移動またはコピーします。

デスクトップに作成した`gyakuten_php`フォルダを

    /MAMP/htdocs

フォルダに移動またはコピーします。

これでPHPファイルを実行する準備は整いましたので、ブラウザ（Google Chrome）を開きURL欄に以下の通り打ち込みます。

    http://localhost8888/gyakuten_php/index.php

すると以下のようにブラウザに表示されます。

    Hello World!

と表示されます。

これでブラウザでPHPファイルの処理を表示することができました。
Macを使いの方は以降は同様の手順でファイルを実行してください。


#### ブラウザで表示する時のコードの書き方


ブラウザに表示する場合、`echo`での文字の出力が１行であれば`n\`は不要です。

```php
<?php 

echo ""Hello World!"";

//実行結果：Hello World!

?>
```

出力を改行させる場合は、index.phpを以下のコードに修正してください。

```php
<?php 

//<br>は改行タグ
echo ""Hello World!<br>"";

echo ""Hello World!""

?>
```
ブラウザを再度読み込むと以下のように表示されます。

    Hello World!
    Hello World!

先ほどのコードで`<br>`を書かずにブラウザを再読み込みすると以下のように改行されずに表示されます。

    Hello World! Hello World!

以上が、`PH`Pファイルの実行結果をWebサーバーを使ってブラウザに表示させる方法です。

本教材では今後、実行が簡単なターミナルでの実行で進めていきます。`XAMPP`や`MAMP`の使い方をマスターしたい方はぜひ使ってみてください。

今回は以上です。

お疲れ様でした！"